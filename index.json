[{"body":"These docs consists of a list of maintained and up-to-date Bitcoin Python libraries. Goal is to provide a solid starting point for Python developers willing to work and interact with Bitcoin protocol. Weather it's constructing transactions or fetching data from a Bitcoin RPC server.\nRunning Bitcoin Bitcoin node can be ran on several networks (mainet, testnet, signet, regtest). Under this section you'll learn how to setup and run a Bitcoin node which you can then use as a \u0026quot;portal\u0026quot; into the Bitcoin protocol. Read more\nLibraries python-bitcoinlib Python3 library providing an interface to Bitcoin data structures and protocol. Read more\nLibrary supports mainnet, testnet and regtest. A PR for signet has been merged but the version that supports it hasn't been released yet.\nbuidl Python3 library with no dependencies. Provides an interface to Bitcoin data structures. There are more functionalities included into this library which are for more advanced use and will be described on this page at later stage. Read more\nLibrary only supports mainnet, testnet and signet and requires internet to work.\nbip_utils This package allows generating mnemonics, seeds, private/public keys and addresses.\nThis unfortunatelly isn't a Bitcoin only library and includes supports for other cryptocurrencies.\nRead more\n","link":"https://bitcoinpy.dev/docs/","title":"Overview"},{"body":"Hierarchical Deterministic Wallets (HD Wallets) A Hierarchical Deterministic (HD) wallet is the term used to describe a wallet which uses a single seed to derive public and private keys. Approach to create HD Wallets was defined under BIP-32. Not using BIP-32 means that you need to create a separate seed every time you created a normal receiving address. Nowadays all popular wallets use this approach to generate receiving addresses.\nBitcoin has different types of addresses: P2PKH, P2WSH (wrapped segwit), P2WPKH (native segwit). That is why additional BIPs were created to define standards what kind of derivation paths should be used to generate specific address types.\nRead BIP-32.\nBIP-44: derive P2PKH addresses According to BIP 44, wallets which generate P2PKH addresses should use a derivation path beginning with m/44'/. This means the first address generated by a mainnet Bitcoin wallet will have a derivation path of m/44'/0'/0'/0/0.\nIn addition, all such wallets which use mainnet Bitcoin should use the xpub or xprv prefix for extended public and private keys respectively. Extended keys using the BIP 44 standard are thus called xpubs and xprvs respectively. If the wallet is a testnet wallet, tpub and tprv prefixes are used instead.\nRead BIP-44.\n1import hashlib 2from bip_utils import Bip44Changes, Bip44Coins, Bip44 34# in previous examples we use sha256 but here we use sha512 due to the min seed length requirement 5# that bip_utils enforces 6h = hashlib.sha512(b\u0026#39;very bad brainwallet\u0026#39;).digest() 78bip44 = Bip44.FromSeed(h, Bip44Coins.BITCOIN) 9bip44_acc = bip44.Purpose().Coin().Account(0) 1011for index in range(5): 12# CHAIN_EXT means it\u0026#39;s an external address (receiving address). CHAIN_INT constant indicates an 13# internal address (used for change) 14bip44_addr = bip44_acc.Change(Bip44Changes.CHAIN_EXT).AddressIndex(index) 15address = bip44_addr.PublicKey().ToAddress() 16print(f\u0026#34;Address {index}: {address}\u0026#34;) 1718# Outputs: 19# Address 0: 1MAjFH9X7C94QGFGcFgegjTko8n1vUCu4A 20# Address 1: 18mEkkjvTPty8uH1LX3hnnZTstS7pbwqrV 21# Address 2: 1PLRhwriNYopoNDsLrKRpiHTfHFdNAkipx 22# Address 3: 19ZyE5du3WeRyWoPuKDw3Lq4e9EuDDeQgK 23# Address 4: 1GXEGfsFwJUAQn1XYV3EYwgJ4hMiKTo8Yg BIP-49: derive wrapped SegWit addresses According to BIP 49, wallets which generate wrapped SegWit addresses should use a derivation path beginning with m/49'/. This means the first address generated by a mainnet Bitcoin wallet will have a derivation path of m/49'/0'/0'/0/0.\nIn addition, all such wallets which use mainnet Bitcoin should use ypub or yprv prefixes for extended public and private keys respectively. Extended keys following the BIP 49 standard are thus called ypubs and yprvs respectively. If the wallet is a testnet wallet, upub and uprv prefixes are used instead.\nRead BIP-49.\n1import hashlib 2from bip_utils import Bip44Changes, Bip49Coins, Bip49 34# in previous examples we use sha256 but here we use sha512 due to the min seed length requirement 5# that bip_utils enforces 6h = hashlib.sha512(b\u0026#39;very bad brainwallet\u0026#39;).digest() 78bip49 = Bip49.FromSeed(h, Bip49Coins.BITCOIN) 9bip49_acc = bip49.Purpose().Coin().Account(0) 1011for index in range(5): 12# CHAIN_EXT means it\u0026#39;s an external address (receiving address). CHAIN_INT constant indicates an 13# internal address (used for change) 14bip49_addr = bip49_acc.Change(Bip44Changes.CHAIN_EXT).AddressIndex(index) 15address = bip49_addr.PublicKey().ToAddress() 16print(f\u0026#34;Address {index}: {address}\u0026#34;) 1718# Outputs: 19# Address 0: 3LjNLKmKAj6KzWz1XkSmhm7LGxaC58sm5Y 20# Address 1: 37yj44W3Y8MjxDZgGmm5bosvUUp3e7oLov 21# Address 2: 32AyxeR6TdCjfSJhoT9jk8ppDnmUSj9KVA 22# Address 3: 3K2TxNH1Xk2oehm3xu7jWZBmJvA6o6ZBFg 23# Address 4: 3K7vkaW2NMDn813mca9Fikd4k6F3jQ1h1t BIP-84: derive native SegWit addresses According to BIP 84, wallets which generate native SegWit addresses should use a derivation path beginning with m/84'/. This means the first address generated by a mainnet Bitcoin wallet will have a derivation path of m/84'/0'/0'/0/0.\nIn addition, BIP 84 states that all wallets which use native SegWit on mainnet should use zpub or zprv prefixes for extended public and private keys respectively. Extended keys following the BIP 84 standard are thus called zpubs and zprvs respectively. If the wallet is a testnet wallet, vpub and vprv prefixes are used instead.\nRead BIP-84.\n1import hashlib 2from bip_utils import Bip44Changes, Bip84Coins, Bip84 34# in previous examples we use sha256 but here we use sha512 due to the min seed length requirement 5# that bip_utils enforces 6h = hashlib.sha512(b\u0026#39;very bad brainwallet\u0026#39;).digest() 78bip84 = Bip84.FromSeed(h, Bip84Coins.BITCOIN) 9bip84_acc = bip84.Purpose().Coin().Account(0) 1011for index in range(5): 12# CHAIN_EXT means it\u0026#39;s an external address (receiving address). CHAIN_INT constant indicates an 13# internal address (used for change) 14bip84_addr = bip84_acc.Change(Bip44Changes.CHAIN_EXT).AddressIndex(index) 15address = bip84_addr.PublicKey().ToAddress() 16print(f\u0026#34;Address {index}: {address}\u0026#34;) 1718# Outputs: 19# Address 0: bc1q3lusppjzw8jqxwlnq8nu2ua8spnzka3gzh52ha 20# Address 1: bc1q3et59vv6qa8ulr8a0vzjykgh9jkvcvltvd5k7p 21# Address 2: bc1qge23sdr36vqn3sca8760y4sy3vsjxe2wuju263 22# Address 3: bc1qz3rnqmueq8jej33a9zh68zm6n58ngfajgrr0f5 23# Address 4: bc1qtsnmsfhd4jkzeml3u5wjjmfe0587vntg6nc6gx BIP-86: derive single key P2TR outputs TODO\nMore info.\n Sources:\n HD Wallet BIP-32 @ River BIP-44 @ River BIP-49 @ River BIP-84 @ River  ","link":"https://bitcoinpy.dev/docs/bip-utils/hd-wallets/","title":"HD Wallets"},{"body":"Generate address 1import hashlib 23from buidl.ecc import PrivateKey, Signature 4from buidl.helper import decode_base58, big_endian_to_int 5from buidl.bech32 import decode_bech32, encode_bech32_checksum 6from buidl.script import P2PKHScriptPubKey, RedeemScript, WitnessScript, P2WPKHScriptPubKey 7from buidl.tx import Tx, TxIn, TxOut 89h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 10private_key = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 11address = private_key.point.bech32_address(\u0026#34;signet\u0026#34;) 12print(\u0026#39;Address:\u0026#39;, str(address)) 13# outputs: Address: tb1q08alc0e5ua69scxhvyma568nvguqccrvl7rkgx Spend from address Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 23txid = bytes.fromhex(\u0026#34;5375b209e02aa4fd665b10fbbfbd5bbe3045a307ddcabd7571f87ab571a41e98\u0026#34;) 4vout = 1 56# Specify the amount send to your P2WSH address. 7COIN = 100000000 8amount = int(0.001 * COIN) 910# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 11# setting on regtest. 12amount_less_fee = int(amount * 0.99) 1314# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 15# is necessary for spending a P2WSH output. 16txin = TxIn(txid, vout) 1718# Specify a destination address and create the txout. 19h160 = decode_bech32(\u0026#34;tb1qqqlcpznqkfa65wqd48mzzghpwzefgpvtvl0a7k\u0026#34;)[2] 20txout = TxOut(amount=amount_less_fee, script_pubkey=P2WPKHScriptPubKey(h160)) 2122tx = Tx(1, [txin], [txout], 0, network=\u0026#34;signet\u0026#34;, segwit=True) 2324redeem_script = private_key.point.p2sh_p2wpkh_redeem_script() 2526# Sign the transaction (buidl makes a request to the explorer to fetch public key here) 27tx.sign_input(0, private_key, redeem_script=redeem_script) 2829# Done! Print the transaction 30print(tx.serialize().hex()) 31# outputs: 01000000000101981ea471b57af87175bdcadd07a34530be5bbdbffb105b66fda42ae009b275530100000000ffffffff01b882010000000000160014003f808a60b27baa380da9f62122e170b294058b02483045022100ca58968430508ce0a36b45c7ad53de85fbf111569ed822d69844fc232df9a7a6022011445083ce81f4cce1e8bc4a82b8338f9025de080dfb7e202352fe66411d117f01210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c7100000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was d1be307fe1d50d1e0044ba6b031cf0ad7d105d4d7d1d1cc6a4abff8dd225386f.\n","link":"https://bitcoinpy.dev/docs/buidl/p2wpkh/","title":"P2WPKH address"},{"body":"Generate address 1import hashlib 23from bitcoin import SelectParams 4from bitcoin.core import b2x, lx, COIN, COutPoint, CTxOut, CTxIn, CTxInWitness, CTxWitness, CScriptWitness, CMutableTransaction, Hash160 5from bitcoin.core.script import CScript, OP_0, SignatureHash, SIGHASH_ALL, SIGVERSION_WITNESS_V0 6from bitcoin.wallet import CBitcoinSecret, P2WPKHBitcoinAddress, CBitcoinAddress 78SelectParams(\u0026#34;regtest\u0026#34;) 91011# Create the (in)famous correct brainwallet secret key. 12h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 13seckey = CBitcoinSecret.from_secret_bytes(h) 1415public_key = seckey.pub 16script_pubkey = CScript([OP_0, Hash160(public_key)]) 17address = P2WPKHBitcoinAddress.from_scriptPubKey(script_pubkey) 1819print(\u0026#39;Address:\u0026#39;, str(address)) 20# outputs: Address: bcrt1q08alc0e5ua69scxhvyma568nvguqccrvah6ml0 Spend from address Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 23txid = lx(\u0026#34;ace85db02052679bf02216e6d3815f082ad52bf3e1e1ef1bbe3854dc45aa9b2c\u0026#34;) 4vout = 1 56# Specify the amount send to your P2WSH address. 7amount = int(1 * COIN) 89# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 10# setting on regtest. 11amount_less_fee = amount * 0.99 1213# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 14# is necessary for spending a P2WSH output. 15txin = CTxIn(COutPoint(txid, vout)) 1617# Specify a destination address and create the txout. 18destination = CBitcoinAddress(\u0026#34;bcrt1qvg69hl7uj3y4x3xpy8dq2rrfdhq4nwmzpx9s6y\u0026#34;).to_scriptPubKey() 1920# Create the unsigned transaction. 21txin = CTxIn(COutPoint(txid, vout)) 22txout = CTxOut(amount_less_fee, destination) 23tx = CMutableTransaction([txin], [txout]) 2425# Calculate the signature hash for that transaction. 26sighash = SignatureHash( 27script=address.to_redeemScript(), 28txTo=tx, 29inIdx=0, 30hashtype=SIGHASH_ALL, 31amount=amount, 32sigversion=SIGVERSION_WITNESS_V0, 33) 34signature = seckey.sign(sighash) + bytes([SIGHASH_ALL]) 3536# Construct a witness for this transaction input. The public key is given in 37# the witness so that the appropriate redeemScript can be calculated by 38# anyone. The original scriptPubKey had only the Hash160 hash of the public 39# key, not the public key itself, and the redeem script can be entirely 40# re-constructed (from implicit template) if given just the public key. So the 41# public key is added to the witness. This is P2WPKH in bip141. 42witness = [signature, public_key] 4344# Aggregate all of the witnesses together, and then assign them to the 45# transaction object. 46ctxinwitnesses = [CTxInWitness(CScriptWitness(witness))] 47tx.wit = CTxWitness(ctxinwitnesses) 4849# Done! Print the transaction 50print(b2x(tx.serialize())) 51# outputs: 010000000001012c9baa45dc5438be1befe1e1f32bd52a085f81d3e61622f09b675220b05de8ac0100000000ffffffff01c09ee6050000000016001462345bffdc94495344c121da050c696dc159bb6202473044022010440396a713c45ef4600521f26fa5af3324ebda16fc451c56fe72366cc4817c022047bce51f6b7ac97972f2612cd3c165774cfedb71b193367afe3f7a718524bb2301210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c7100000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was d8183c2c7564d4458d019ea6fa4d546c13d6d37fd3c53695bcdc80c352d88c4b.\n","link":"https://bitcoinpy.dev/docs/python-bitcoinlib/p2wpkh/","title":"P2WPKH address"},{"body":"Running Bitcoin is easy. This section with show you how to get your node up and running.\nInstallating We'll be install Bitcoin binary files here. In case you'd prefer to build and install Bitcoin from source have a look at a relevant build- file for your operating system.\nBelow steps are intended for users running Linux. We might add guides for other OS in the future.\n Download a relevant file from: https://bitcoincore.org/en/download/ Extract the files: tar xvzf bitcoin-22.0-x86_64-linux-gnu.tar.gz Verify your download Copy binary files to local bin directory so they can be accessed from anywhere, eg: sudo cp bitcoin-22.0/bin/* /usr/local/bin/  Configuring Now that you have successfully installed Bitcoin, we'll go ahead with the configuration.\nBitcoin node can run on several networks:\n mainnet: main (production) network, these is the only network where coins have value testnet: public testnet network with a long history where things are tested, this network mimics mainnet as much as possible which is why it's based on PoW signet: new type of public testnet network with centralized consensus where a dedicated entity or a group with authority to create new blocks can produce new blocks using valid signatures (not PoW based) regtest: private (sandboxed) version of testnet for individual developers where developer himself has a full control (spinning up and connecting nodes, minig blocks (no actualy PoW needed), triggering manual reorgs etc.)  During this configuration we will guide you to configure a node that will connect to testnet. Later on we will explain how to connect to other networks.\n1. Create configuration file  Create a .bitcoin folder in your home directory: mkdir ~/.bitcoin Create a bitcoin.conf file to this directory: touch .bitcoin/bitcoin.conf  By default all bitcoin binaries read the configuration from ~/.bitcoin/bitcoin.conf path.\n2. Setup configuration file For more info about specific configuration parameters visit bitcoin.conf example file and jlopp's config generator.\n1# Generated by https://jlopp.github.io/bitcoin-core-config-generator/ 23# This config should be placed in following path: 4# ~/.bitcoin/bitcoin.conf 56# [chain] 7# Run this node on the Bitcoin Test Network. Equivalent to -chain=test 8testnet=1 910# [debug] 11# Enable debug logging for all categories. 12debug=1 1314# [network] 15# Automatically create Tor hidden service. 16listenonion=0 1718# [rpc] 19# Accept command line and JSON-RPC commands. 20server=1 21rpcuser=user-change-me 22rpcpassword=password-change-me 232425# [Sections] 26# Most options automatically apply to mainnet, testnet, and regtest networks. 27# If you want to confine an option to just one network, you should add it in the relevant section. 28# EXCEPTIONS: The options addnode, connect, port, bind, rpcport, rpcbind and wallet 29# only apply to mainnet unless they appear in the appropriate section below. 3031# Options only for mainnet 32[main] 3334# Options only for testnet 35[test] 3637# Options only for regtest 38[regtest] 3940# Options only for signet 41[regtest] 3. Run Bitcoin You can start the node by running bitcoind. You should see youre node booting up and starting to sync. Syncing on testnet takes a few hours and with our configuration it will eat up around 40gb of disk space.\nIf you'd prefer to start a bitcoind as a background process you need to run it with daemon mode enabled eg: bitcoind -daemon. To see output as you did before you can see the logs in .bitcoin/testnet3/debug.log.\nCongratulations ðŸŽ‰ You're running Bitcoin.\nRun on other networks In order to connect to networks other than testnet (the one we used in the example config file), you'll need to make some modifications.\nMainnet Modify the config:\n Under [chain] replace testnet=1 with mainnet=1.  1# [chain] 2mainnet=1 Signet Modify the config:\n Under [chain] replace testnet=1 with signet=1.  1# [chain] 2signet=1 Regtest Modify the config:\n Under [chain] replace testnet=1 with regtest=1.  1# [chain] 2regtest=1 Add the following to the bitcoin.conf file  1# [relay] 2minrelaytxfee=0.00001 ","link":"https://bitcoinpy.dev/docs/running-bitcoin/","title":"Running Bitcoin"},{"body":"Bitcoin doesn't actually have different types of transactions but has different types of address formats. Each address has a different way of \u0026quot;unlocking\u0026quot; its funds. The way that dictates how to unlock funds is set (or scripted) at the time when the address is generated.\nP2PKH P2PKH is an abbreviation for Pay to Public Key Hash. It locks bitcoins to the hash of a public key, this is most commonly used for payments.\nNote that P2PKH is considered to be a legacy address so P2WPKH should be used instead.\nP2SH P2SH is an abbreviation for Pay to Script Hash. It allows you to lock coins to the hash of a script, and you then provide that original script when you come unlock those coins. P2SH locks bitcoins to the hash of a script, this format enabled more advanced functionalities (eg. MultiSigs, HTLCs etc.).\nNote that P2SH is considered to be a legacy address so P2WSH should be used instead.\n\u0026quot;Script Hash addresses\u0026quot; are intended for multisig or other \u0026quot;smart contract\u0026quot; address. If all you wish to do is receive payment to an address (without multisig) it's better to use P2WPKH as it's cheaper to spend from those addresses.  P2WPKH (SegWit) P2WPKH is an abbreviation for Pay to Witness Public Key Hash. P2WPKH is the native Segwit version of a P2PKH.\nP2WPKH has the same semantics as P2PKH, except that the signature is not placed at the same location as before. Segregated Witness (SegWit) moves the proof of ownership from the scriptSig part of the transaction to a new part called the witness of the input which as a result makes transactions smaller and cheaper.\nP2WSH (SegWit) P2WSH is an abbreviation for Pay to Witness Script Hash. P2WSH is the native Segwit version of a P2SH.\n\u0026quot;Script Hash addresses\u0026quot; are intended for multisig or other \u0026quot;smart contract\u0026quot; address. If all you wish to do is receive payment to an address (without multisig) it's better to use P2WPKH as it's cheaper to spend from those addresses.  P2WSH has the same semantics as P2SH, except that the signature is not placed at the same location as before. Segregated Witness (SegWit) moves the proof of ownership from the scriptSig part of the transaction to a new part called the witness of the input which as a result makes transactions smaller and cheaper.\nScript Hash allows you to lock coins to the hash of a script, and you then provide that original script when you come to unlock those coins.\nP2TR (Taproot) Locks bitcoins to a script that can be unlocked by a public key or a MAST (Merkelized Alternative Script Tree). MAST expands the flexibility and utility of Bitcoin contracts in an inexpensive and privacy preserving way.\nP2SH-P2WPKH (Wrapped SegWit) \u0026quot;Wrapped\u0026quot; SegWit address for P2WPKH it enables software that doesn't support SegWit natively to be able to send to SegWit addresses. This format is actually P2SH but it uses a native SegWit P2WPKH script as redeem scripts of a P2SH.\nP2SH-P2WSH (Wrapped SegWit) \u0026quot;Wrapped\u0026quot; SegWit address for P2WSH, it enables software that doesn't support SegWit natively to be able to send to SegWit addresses. This format is actually P2SH but it uses a native SegWit P2WSH script as redeem scripts of a P2SH.\n Sources:\n Wrapped Segwit Trezor's Wiki Bitcoin Developer Network BIP-141  ","link":"https://bitcoinpy.dev/docs/intro-to-transactions/","title":"Intro to Transactions"},{"body":" The example for 1-of-1 should only serve as an example. We don't recommend using it in the real world because it is not its intention. Instead of 1-of-1 use P2PKH!  Generate address (1-of-1) 1import hashlib 23from buidl.ecc import PrivateKey, Signature 4from buidl.helper import decode_base58, big_endian_to_int 5from buidl.bech32 import decode_bech32, encode_bech32_checksum 6from buidl.script import P2PKHScriptPubKey, RedeemScript, WitnessScript, P2WPKHScriptPubKey 7from buidl.tx import Tx, TxIn, TxOut 8from buidl.witness import Witness 910h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 11private_key = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 1213# Create a witnessScript. witnessScript in SegWit is equivalent to redeemScript in P2SH transaction, 14# however, while the redeemScript of a P2SH transaction is included in the ScriptSig, the  15# WitnessScript is included in the Witness field, making P2WSH inputs cheaper to spend than P2SH  16# inputs. 17witness_script = WitnessScript([private_key.point.sec(), 0xac]) 1819address = witness_script.address(\u0026#34;signet\u0026#34;) 20print(\u0026#39;Address:\u0026#39;, str(address)) 21# outputs: tb1qgatzazqjupdalx4v28pxjlys2s3yja9gr3xuca3ugcqpery6c3sqtuzpzy Spend from address (1-of-1) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 23txid = bytes.fromhex(\u0026#34;f24d3d8c85ded6d0fbe898a09a2c9f8a8388e4edcf139e52c8714814d85f8273\u0026#34;) 4vout = 0 56# Specify the amount send to your P2WSH address. 7COIN = 100000000 8amount = int(0.001 * COIN) 910# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 11# setting on regtest. 12amount_less_fee = int(amount * 0.99) 1314# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 15# is necessary for spending a P2WSH output. 16txin = TxIn(txid, vout) 1718# Specify a destination address and create the txout. 19h160 = decode_bech32(\u0026#34;tb1qqqlcpznqkfa65wqd48mzzghpwzefgpvtvl0a7k\u0026#34;)[2] 20txout = TxOut(amount=amount_less_fee, script_pubkey=P2WPKHScriptPubKey(h160)) 2122tx = Tx(1, [txin], [txout], 0, network=\u0026#34;signet\u0026#34;, segwit=True) 2324sig1 = tx.get_sig_segwit(0, private_key, witness_script=witness_script) 2526tx.check_sig_segwit( 270, 28private_key.point, 29Signature.parse(sig1[:-1]), 30witness_script=witness_script, 31) 3233txin.witness = Witness([sig1, witness_script.raw_serialize()]) 3435print(tx.serialize().hex()) 36# outputs: 0100000000010173825fd8144871c8529e13cfede488838a9f2c9aa098e8fbd0d6de858c3d4df20000000000ffffffff01b882010000000000160014003f808a60b27baa380da9f62122e170b294058b0247304402201b812e3a58b18bf83ee65db660af469708583073beaecbd4d7147757068e5ece022034a0b51dc40cdbcba1362f544a467e3dc605395f5e0029d5d2e342aea1ddfac20123210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c71ac00000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 19e8dc2d719e14bc652bda4809007a72c17bdee6e174d4c02f570c48cad691cd.\nGenerate address (2-of-2) In this example we show how to create a 2-of-2 multisig address. This means that two signatures are required in order to unlock funds.\n1import hashlib 23from buidl.ecc import PrivateKey, Signature 4from buidl.helper import decode_base58, big_endian_to_int 5from buidl.bech32 import decode_bech32, encode_bech32_checksum 6from buidl.script import P2PKHScriptPubKey, RedeemScript, WitnessScript, P2WPKHScriptPubKey 7from buidl.tx import Tx, TxIn, TxOut 8from buidl.witness import Witness 910# first key 11h = hashlib.sha256(b\u0026#39;correct horse battery staple first\u0026#39;).digest() 12private_key1 = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 1314# second key 15h = hashlib.sha256(b\u0026#39;correct horse battery staple second\u0026#39;).digest() 16private_key2 = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 1718# Create a witnessScript. witnessScript in SegWit is equivalent to redeemScript in P2SH transaction, 19# however, while the redeemScript of a P2SH transaction is included in the ScriptSig, the  20# WitnessScript is included in the Witness field, making P2WSH inputs cheaper to spend than P2SH  21# inputs. 22witness_script = WitnessScript( 23[0x52, private_key1.point.sec(), private_key2.point.sec(), 0x52, 0xAE] 24) 2526address = witness_script.address(\u0026#34;signet\u0026#34;) 27print(\u0026#39;Address:\u0026#39;, str(address)) 28# outputs: tb1qljlyqaexx4mmhpl66e6nqdtagjaht87pghuq6p0f98a765c9uj9susmlvt Spend from address (2-of-2) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 23txid = bytes.fromhex(\u0026#34;e810379ffa5ca20a30f2210d93517aef28d3f20e20b920190161d4f6491a0903\u0026#34;) 4vout = 0 56# Specify the amount send to your P2WSH address. 7COIN = 100000000 8amount = int(0.001 * COIN) 910# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 11# setting on regtest. 12amount_less_fee = int(amount * 0.99) 1314# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 15# is necessary for spending a P2WSH output. 16txin = TxIn(txid, vout) 1718# Specify a destination address and create the txout. 19h160 = decode_bech32(\u0026#34;tb1qwp3c26rlgzlq4axergvt04300shexn4f56q5f7\u0026#34;)[2] 20txout = TxOut(amount=amount_less_fee, script_pubkey=P2WPKHScriptPubKey(h160)) 2122tx = Tx(1, [txin], [txout], 0, network=\u0026#34;signet\u0026#34;, segwit=True) 2324sig1 = tx.get_sig_segwit(0, private_key1, witness_script=witness_script) 25sig2 = tx.get_sig_segwit(0, private_key2, witness_script=witness_script) 2627tx.check_sig_segwit( 280, 29private_key1.point, 30Signature.parse(sig1[:-1]), 31witness_script=witness_script, 32) 3334tx.check_sig_segwit( 350, 36private_key2.point, 37Signature.parse(sig2[:-1]), 38witness_script=witness_script, 39) 4041txin.finalize_p2wsh_multisig([sig1, sig2], witness_script) 4243print(tx.serialize().hex()) 44# outputs: 0100000000010103091a49f6d461011920b9200ef2d328ef7a51930d21f2300aa25cfa9f3710e80000000000ffffffff01b882010000000000160014706385687f40be0af4d91a18b7d62f7c2f934ea90400483045022100b24100d90fdd15d3e694789106f780c4c13f4929ec5cc82445418bedac9dfc93022038f5cc4ade88b41f1398d5f1e31a9d4f9d861f67aa24dff30a6d20e509b591c801483045022100fa9f78c7769010a57aa96939b32fad0d216a1dcf3a1f44a09f0e7b29f56b773402207a795dad938599c920d864001b454ae2f44358f5ac098e913049ea7fd9925cb001475221038d19497c3922b807c91b829d6873ae5bfa2ae500f3237100265a302fdce87b052103d3a9dff5a0bb0267f19a9ee1c374901c39045fbe041c1c168d4da4ce0112595552ae00000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 6064651b405e0e1d6b5cdc0056c3deda11af3593ca64d43b1cd4abff45b7376b.\nGenerate address (1-of-3) In this example we show how to create a 1-of-3 multisig address. This means that one out of three signatures can unlock and spend bitcoins.\n1import hashlib 23from buidl.ecc import PrivateKey, Signature 4from buidl.helper import decode_base58, big_endian_to_int 5from buidl.bech32 import decode_bech32, encode_bech32_checksum 6from buidl.script import P2PKHScriptPubKey, RedeemScript, WitnessScript, P2WPKHScriptPubKey 7from buidl.tx import Tx, TxIn, TxOut 8from buidl.witness import Witness 910# first key 11h = hashlib.sha256(b\u0026#39;correct horse battery staple first\u0026#39;).digest() 12private_key1 = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 1314# second key 15h = hashlib.sha256(b\u0026#39;correct horse battery staple second\u0026#39;).digest() 16private_key2 = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 1718# third key 19h = hashlib.sha256(b\u0026#39;correct horse battery staple third\u0026#39;).digest() 20private_key3 = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 2122# Create a witnessScript. witnessScript in SegWit is equivalent to redeemScript in P2SH transaction, 23# however, while the redeemScript of a P2SH transaction is included in the ScriptSig, the  24# WitnessScript is included in the Witness field, making P2WSH inputs cheaper to spend than P2SH  25# inputs. 26witness_script = WitnessScript( 27[0x51, private_key1.point.sec(), private_key2.point.sec(), private_key3.point.sec(), 0x53, 0xAE] 28) 2930address = witness_script.address(\u0026#34;signet\u0026#34;) 31print(\u0026#39;Address:\u0026#39;, str(address)) 32# outputs: tb1qywycrgq9mvh7lm607hfz2nr99juda6v7ks5gvdtg6qz4l6f80nsqu9wr4h Spend from address (1-of-3) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 23txid = bytes.fromhex(\u0026#34;430f7f5ef675a910786f335cabff19d6661910ea365097c6fa1d72e97803ea81\u0026#34;) 4vout = 0 56# Specify the amount send to your P2WSH address. 7COIN = 100000000 8amount = int(0.001 * COIN) 910# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 11# setting on regtest. 12amount_less_fee = int(amount * 0.99) 1314# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 15# is necessary for spending a P2WSH output. 16txin = TxIn(txid, vout) 1718# Specify a destination address and create the txout. 19h160 = decode_bech32(\u0026#34;tb1qwp3c26rlgzlq4axergvt04300shexn4f56q5f7\u0026#34;)[2] 20txout = TxOut(amount=amount_less_fee, script_pubkey=P2WPKHScriptPubKey(h160)) 2122tx = Tx(1, [txin], [txout], 0, network=\u0026#34;signet\u0026#34;, segwit=True) 2324sig2 = tx.get_sig_segwit(0, private_key2, witness_script=witness_script) 2526tx.check_sig_segwit( 270, 28private_key2.point, 29Signature.parse(sig2[:-1]), 30witness_script=witness_script, 31) 3233txin.finalize_p2wsh_multisig([sig2], witness_script) 3435print(tx.serialize().hex()) 36# outputs: 0100000000010181ea0378e9721dfac6975036ea101966d619ffab5c336f7810a975f65e7f0f430000000000ffffffff01b882010000000000160014706385687f40be0af4d91a18b7d62f7c2f934ea90300473044022036d2596a339e9205d8916d457aeba40332abce8a8435fdb428b1d1b93a8b1af202202fddec53a106e0f8d2d788f83206a3e2e9b9abacf74f0cc16c4458be9c6b89f501695121038d19497c3922b807c91b829d6873ae5bfa2ae500f3237100265a302fdce87b052103d3a9dff5a0bb0267f19a9ee1c374901c39045fbe041c1c168d4da4ce01125955210228769768e3083e084dd5c03b6077d51b7e7a22bd66fc99ff481dcf9b6b80d03053ae00000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 3fbd9fe43c30c9af8852f6eaf3e0f1158079195e9b9eea51576445f6c8098fdb.\nGenerate address (2-of-3) In this example we show how to create a 2-of-3 multisig address. This means that two out of three signatures can unlock and spend bitcoins.\n1import hashlib 23from buidl.ecc import PrivateKey, Signature 4from buidl.helper import decode_base58, big_endian_to_int 5from buidl.bech32 import decode_bech32, encode_bech32_checksum 6from buidl.script import P2PKHScriptPubKey, RedeemScript, WitnessScript, P2WPKHScriptPubKey 7from buidl.tx import Tx, TxIn, TxOut 8from buidl.witness import Witness 910# first key 11h = hashlib.sha256(b\u0026#39;correct horse battery staple first\u0026#39;).digest() 12private_key1 = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 1314# second key 15h = hashlib.sha256(b\u0026#39;correct horse battery staple second\u0026#39;).digest() 16private_key2 = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 1718# third key 19h = hashlib.sha256(b\u0026#39;correct horse battery staple third\u0026#39;).digest() 20private_key3 = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 2122# Create a witnessScript. witnessScript in SegWit is equivalent to redeemScript in P2SH transaction, 23# however, while the redeemScript of a P2SH transaction is included in the ScriptSig, the  24# WitnessScript is included in the Witness field, making P2WSH inputs cheaper to spend than P2SH  25# inputs. 26witness_script = WitnessScript( 27[0x52, private_key1.point.sec(), private_key2.point.sec(), private_key3.point.sec(), 0x53, 0xAE] 28) 2930address = witness_script.address(\u0026#34;signet\u0026#34;) 31print(\u0026#39;Address:\u0026#39;, str(address)) 32# outputs: tb1q3xlhms84s9vakaa3ds6pzh849mkddvfqmkp43unxyac4stkyyssseuv3rk Spend from address (2-of-3) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 23txid = bytes.fromhex(\u0026#34;271ec7372f58eda37ab686a1ad08cd1cac0188b51bcc29d40f8bc5aa06b4db85\u0026#34;) 4vout = 0 56# Specify the amount send to your P2WSH address. 7COIN = 100000000 8amount = int(0.001 * COIN) 910# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 11# setting on regtest. 12amount_less_fee = int(amount * 0.99) 1314# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 15# is necessary for spending a P2WSH output. 16txin = TxIn(txid, vout) 1718# Specify a destination address and create the txout. 19h160 = decode_bech32(\u0026#34;tb1qwp3c26rlgzlq4axergvt04300shexn4f56q5f7\u0026#34;)[2] 20txout = TxOut(amount=amount_less_fee, script_pubkey=P2WPKHScriptPubKey(h160)) 2122tx = Tx(1, [txin], [txout], 0, network=\u0026#34;signet\u0026#34;, segwit=True) 2324sig2 = tx.get_sig_segwit(0, private_key2, witness_script=witness_script) 25sig3 = tx.get_sig_segwit(0, private_key3, witness_script=witness_script) 2627tx.check_sig_segwit( 280, 29private_key2.point, 30Signature.parse(sig2[:-1]), 31witness_script=witness_script, 32) 33tx.check_sig_segwit( 340, 35private_key3.point, 36Signature.parse(sig3[:-1]), 37witness_script=witness_script, 38) 394041txin.finalize_p2wsh_multisig([sig2, sig3], witness_script) 4243print(tx.serialize().hex()) 44# outputs: 0100000000010185dbb406aac58b0fd429cc1bb58801ac1ccd08ada186b67aa3ed582f37c71e270000000000ffffffff01b882010000000000160014706385687f40be0af4d91a18b7d62f7c2f934ea904004730440220378efe62e2d47d3a0301a71a4f50263f62d8b6ffd42638a4f1f12ff54b1a653b02204998939a432ddd60a60b5d5051d9abbd282520ad1d9a56852cb83bbb32013abf014830450221008ea8d8ed0bdb1c69390af52786bfe3a5702cf48bf804484b5782eb50f39c23d1022020eaee9a54d8e7bfa2fee5a4ef4a86bad6049c8a8de42ea5ae35c00b98623b3e01695221038d19497c3922b807c91b829d6873ae5bfa2ae500f3237100265a302fdce87b052103d3a9dff5a0bb0267f19a9ee1c374901c39045fbe041c1c168d4da4ce01125955210228769768e3083e084dd5c03b6077d51b7e7a22bd66fc99ff481dcf9b6b80d03053ae00000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 056b104250da42463ef8b203ae5967a4193057a449c575f1d5d74f9cbb238dd2.\n","link":"https://bitcoinpy.dev/docs/buidl/p2wsh-multisig/","title":"P2WSH address (multisig)"},{"body":" The example for 1-of-1 should only serve as an example. We don't recommend using it in the real world because it is not its intention. Instead of 1-of-1 use P2PKH!  Generate address (1-of-1) 1import hashlib 23from bitcoin import SelectParams 4from bitcoin.core import b2x, lx, COIN, COutPoint, CMutableTxOut, CMutableTxIn, CMutableTransaction, CTxInWitness, CTxWitness 5from bitcoin.core.script import CScript, CScriptWitness, OP_0, OP_CHECKSIG, SignatureHash, SIGHASH_ALL, SIGVERSION_WITNESS_V0 6from bitcoin.wallet import CBitcoinSecret, CBitcoinAddress, P2WSHBitcoinAddress 78# We\u0026#39;ll be using regtest throughout this guide 9SelectParams(\u0026#34;regtest\u0026#34;) 1011# Create the (in)famous correct brainwallet secret key. 12h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 13seckey = CBitcoinSecret.from_secret_bytes(h) 1415# Create a witnessScript. witnessScript in SegWit is equivalent to redeemScript in P2SH transaction, 16# however, while the redeemScript of a P2SH transaction is included in the ScriptSig, the  17# WitnessScript is included in the Witness field, making P2WSH inputs cheaper to spend than P2SH  18# inputs. 19witness_script = CScript([seckey.pub, OP_CHECKSIG]) 20script_hash = hashlib.sha256(witness_script).digest() 21script_pubkey = CScript([OP_0, script_hash]) 2223# Convert the P2WSH scriptPubKey to a base58 Bitcoin address and print it. 24# You\u0026#39;ll need to send some funds to it to create a txout to spend. 25address = P2WSHBitcoinAddress.from_scriptPubKey(script_pubkey) 26print(\u0026#39;Address:\u0026#39;, str(address)) 27# outputs: Address: bcrt1qgatzazqjupdalx4v28pxjlys2s3yja9gr3xuca3ugcqpery6c3sqx9g8h7 Spend from address (1-of-1) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 23txid = lx(\u0026#34;06d72b86c6200f5721c5de22e77a4e9fa5942eeb64d9ccb8232855575eaacec7\u0026#34;) 4vout = 0 56# Specify the amount send to your P2WSH address. 7amount = int(1 * COIN) 89# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 10# setting on regtest. 11amount_less_fee = amount * 0.99 1213# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 14# is necessary for spending a P2WSH output. 15txin = CMutableTxIn(COutPoint(txid, vout)) 1617# Specify a destination address and create the txout. 18destination = CBitcoinAddress(\u0026#34;bcrt1q5j2zfz4gqe6kd68w9m4ed42n5v2qhfkapqadf0\u0026#34;).to_scriptPubKey() 19txout = CMutableTxOut(amount_less_fee, destination) 2021# Create the unsigned transaction. 22tx = CMutableTransaction([txin], [txout]) 2324# Calculate the signature hash for that transaction. 25sighash = SignatureHash( 26script=witness_script, 27txTo=tx, 28inIdx=0, 29hashtype=SIGHASH_ALL, 30amount=amount, 31sigversion=SIGVERSION_WITNESS_V0, 32) 3334# Now sign it. We have to append the type of signature we want to the end, in this case the usual 35# SIGHASH_ALL. 36sig = seckey.sign(sighash) + bytes([SIGHASH_ALL]) 3738# Construct a witness for this P2WSH transaction and add to tx. 39witness = CScriptWitness([sig, witness_script]) 40tx.wit = CTxWitness([CTxInWitness(witness)]) 4142# Done! Print the transaction 43print(b2x(tx.serialize())) 44# outputs: 01000000000101c7ceaa5e57552823b8ccd964eb2e94a59f4e7ae722dec521570f20c6862bd7060000000000ffffffff01c09ee60500000000160014a494248aa8067566e8ee2eeb96d553a3140ba6dd02473044022031e858a32ab783a5a1c991b1dc67439d00ac5309ea9c7a144dd742835d9a5abe022030f0142bc37886a0cb73fc7d3701d57b682b12328af0f50bc511089f269e9c010123210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c71ac00000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 2f033335f99298cefa1895c399b2ab41f0dd1c9141b746159b2f9416dab53133.\nGenerate address (2-of-2) In this example we show how to create a 2-of-2 multisig address. This means that two signatures are required in order to unlock funds.\n1import hashlib 23from bitcoin import SelectParams 4from bitcoin.core import b2x, lx, COIN, COutPoint, CMutableTxOut, CMutableTxIn, CMutableTransaction, CTxInWitness, CTxWitness 5from bitcoin.core.script import CScript, CScriptWitness, OP_0, OP_2, OP_CHECKMULTISIG, SignatureHash, SIGHASH_ALL, SIGVERSION_WITNESS_V0 6from bitcoin.wallet import CBitcoinSecret, CBitcoinAddress, P2WSHBitcoinAddress 78# We\u0026#39;ll be using regtest throughout this guide 9SelectParams(\u0026#34;regtest\u0026#34;) 1011# Create the (in)famous correct brainwallet secret key. 12# first key 13h1 = hashlib.sha256(b\u0026#39;correct horse battery staple first\u0026#39;).digest() 14seckey1 = CBitcoinSecret.from_secret_bytes(h1) 1516# second key 17h2 = hashlib.sha256(b\u0026#39;correct horse battery staple second\u0026#39;).digest() 18seckey2 = CBitcoinSecret.from_secret_bytes(h2) 1920# Create a witnessScript. witnessScript in SegWit is equivalent to redeemScript in P2SH transaction, 21# however, while the redeemScript of a P2SH transaction is included in the ScriptSig, the  22# WitnessScript is included in the Witness field, making P2WSH inputs cheaper to spend than P2SH  23# inputs. 24witness_script = CScript([OP_2, seckey1.pub, seckey2.pub, OP_2, OP_CHECKMULTISIG]) 25script_hash = hashlib.sha256(witness_script).digest() 26script_pubkey = CScript([OP_0, script_hash]) 2728# Convert the P2WSH scriptPubKey to a base58 Bitcoin address and print it. 29# You\u0026#39;ll need to send some funds to it to create a txout to spend. 30address = P2WSHBitcoinAddress.from_scriptPubKey(script_pubkey) 31print(\u0026#39;Address:\u0026#39;, str(address)) 32# outputs: Address: bcrt1qljlyqaexx4mmhpl66e6nqdtagjaht87pghuq6p0f98a765c9uj9s3f3ee3 Spend from address (2-of-2) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 23txid = lx(\u0026#34;49ff22c9985c1991791b7a3bd6a2e8d1d6567ca283e0885afdc83bd92f56d1c4\u0026#34;) 4vout = 0 56# Specify the amount send to your P2WSH address. 7amount = int(1 * COIN) 89# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 10# setting on regtest. 11amount_less_fee = amount * 0.99 1213# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 14# is necessary for spending a P2WSH output. 15txin = CMutableTxIn(COutPoint(txid, vout)) 1617# Specify a destination address and create the txout. 18destination = CBitcoinAddress(\u0026#34;bcrt1q0q579hm06qf655cr6ns274udgf6k9x7nedkeaa\u0026#34;).to_scriptPubKey() 19txout = CMutableTxOut(amount_less_fee, destination) 2021# Create the unsigned transaction. 22tx = CMutableTransaction([txin], [txout]) 2324# Calculate the signature hash for that transaction. 25sighash = SignatureHash( 26script=witness_script, 27txTo=tx, 28inIdx=0, 29hashtype=SIGHASH_ALL, 30amount=amount, 31sigversion=SIGVERSION_WITNESS_V0, 32) 3334# Now sign it. We have to append the type of signature we want to the end, in this case the usual 35# SIGHASH_ALL. 36sig1 = seckey1.sign(sighash) + bytes([SIGHASH_ALL]) 37sig2 = seckey2.sign(sighash) + bytes([SIGHASH_ALL]) 3839# Construct a witness for this P2WSH transaction and add to tx. 40witness = CScriptWitness([b\u0026#34;\u0026#34;, *[sig1, sig2], witness_script]) 41tx.wit = CTxWitness([CTxInWitness(witness)]) 4243# Done! Print the transaction 44print(b2x(tx.serialize())) 45# outputs: 01000000000101c4d1562fd93bc8fd5a88e083a27c56d6d1e8a2d63b7a1b7991195c98c922ff490000000000ffffffff01c09ee605000000001600147829e2df6fd013aa5303d4e0af578d4275629bd30400483045022100fef9da5dfaea90104f033960b00612753197bf96c69fce097699aff60261aa3402203b72ed27c929125e5aa0066e6f641b7ffaee4bb6e4929a2428e79a2e0ed4f0140148304502210094fca9f85165c024cace7e92a099be3199e427103a971fd6336ce7386bb8fe410220046b043475b72ee5f9fa2872344c689ee9c800031010db0c11fdb57b0d37ab6301475221038d19497c3922b807c91b829d6873ae5bfa2ae500f3237100265a302fdce87b052103d3a9dff5a0bb0267f19a9ee1c374901c39045fbe041c1c168d4da4ce0112595552ae00000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 8a5115099d07455670db03f791f3caf9788bb9eea4a0d5b7133c3ff804d262ac.\nGenerate address (1-of-3) In this example we show how to create a 1-of-3 multisig address. This means that one out of three signatures can unlock and spend bitcoins.\n1import hashlib 23from bitcoin import SelectParams 4from bitcoin.core import b2x, lx, COIN, COutPoint, CMutableTxOut, CMutableTxIn, CMutableTransaction, CTxInWitness, CTxWitness 5from bitcoin.core.script import CScript, CScriptWitness, OP_0, OP_1, OP_3, OP_CHECKMULTISIG, SignatureHash, SIGHASH_ALL, SIGVERSION_WITNESS_V0 6from bitcoin.wallet import CBitcoinSecret, CBitcoinAddress, P2WSHBitcoinAddress 78# We\u0026#39;ll be using regtest throughout this guide 9SelectParams(\u0026#34;regtest\u0026#34;) 1011# Create the (in)famous correct brainwallet secret key. 12# first key 13h1 = hashlib.sha256(b\u0026#39;correct horse battery staple first\u0026#39;).digest() 14seckey1 = CBitcoinSecret.from_secret_bytes(h1) 1516# second key 17h2 = hashlib.sha256(b\u0026#39;correct horse battery staple second\u0026#39;).digest() 18seckey2 = CBitcoinSecret.from_secret_bytes(h2) 1920# third key 21h3 = hashlib.sha256(b\u0026#39;correct horse battery staple third\u0026#39;).digest() 22seckey3 = CBitcoinSecret.from_secret_bytes(h2) 2324# Create a witnessScript. witnessScript in SegWit is equivalent to redeemScript in P2SH transaction, 25# however, while the redeemScript of a P2SH transaction is included in the ScriptSig, the  26# WitnessScript is included in the Witness field, making P2WSH inputs cheaper to spend than P2SH  27# inputs. 28witness_script = CScript([OP_1, seckey1.pub, seckey2.pub, seckey3.pub, OP_3, OP_CHECKMULTISIG]) 29script_hash = hashlib.sha256(witness_script).digest() 30script_pubkey = CScript([OP_0, script_hash]) 3132# Convert the P2WSH scriptPubKey to a base58 Bitcoin address and print it. 33# You\u0026#39;ll need to send some funds to it to create a txout to spend. 34address = P2WSHBitcoinAddress.from_scriptPubKey(script_pubkey) 35print(\u0026#39;Address:\u0026#39;, str(address)) 36# outputs: Address: bcrt1qt5s78re655w4ls6t2pdgl3mttnqmp3acekgx2n6wuad2cj5cne2s4ktpvj Spend from address (1-of-3) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 23txid = lx(\u0026#34;d8b82af8cf10749dd8bfc703c1ff414ce3d2cdd08c2e2004f720721b91f43fe1\u0026#34;) 4vout = 0 56# Specify the amount send to your P2WSH address. 7amount = int(1 * COIN) 89# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 10# setting on regtest. 11amount_less_fee = amount * 0.99 1213# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 14# is necessary for spending a P2WSH output. 15txin = CMutableTxIn(COutPoint(txid, vout)) 1617# Specify a destination address and create the txout. 18destination = CBitcoinAddress(\u0026#34;bcrt1q0q579hm06qf655cr6ns274udgf6k9x7nedkeaa\u0026#34;).to_scriptPubKey() 19txout = CMutableTxOut(amount_less_fee, destination) 2021# Create the unsigned transaction. 22tx = CMutableTransaction([txin], [txout]) 2324# Calculate the signature hash for that transaction. 25sighash = SignatureHash( 26script=witness_script, 27txTo=tx, 28inIdx=0, 29hashtype=SIGHASH_ALL, 30amount=amount, 31sigversion=SIGVERSION_WITNESS_V0, 32) 3334# Now sign it. We have to append the type of signature we want to the end, in this case the usual 35# SIGHASH_ALL. 36sig2 = seckey2.sign(sighash) + bytes([SIGHASH_ALL]) 3738# Construct a witness for this P2WSH transaction and add to tx. 39witness = CScriptWitness([b\u0026#34;\u0026#34;, *[sig2], witness_script]) 40tx.wit = CTxWitness([CTxInWitness(witness)]) 4142# Done! Print the transaction 43print(b2x(tx.serialize())) 44# outputs: 01000000000101e13ff4911b7220f704202e8cd0cdd2e34c41ffc103c7bfd89d7410cff82ab8d80000000000ffffffff01c09ee605000000001600147829e2df6fd013aa5303d4e0af578d4275629bd30300483045022100820cf6fc7610c77f5a0df04b58334afe6ee7e70dc000386884049049801c59040220142749c8a88eefc5bf0f123773ac385e79d837b505359c7d87465d843509743101695121038d19497c3922b807c91b829d6873ae5bfa2ae500f3237100265a302fdce87b052103d3a9dff5a0bb0267f19a9ee1c374901c39045fbe041c1c168d4da4ce011259552103d3a9dff5a0bb0267f19a9ee1c374901c39045fbe041c1c168d4da4ce0112595553ae00000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 53e73442d40f8711a5f9b3ea47270498cb3ae8addd9a4d88a1513b48b6aaad19.\nGenerate address (2-of-3) In this example we show how to create a 2-of-3 multisig address. This means that two out of three signatures can unlock and spend bitcoins.\n1import hashlib 23from bitcoin import SelectParams 4from bitcoin.core import b2x, lx, COIN, COutPoint, CMutableTxOut, CMutableTxIn, CMutableTransaction, CTxInWitness, CTxWitness 5from bitcoin.core.script import CScript, CScriptWitness, OP_0, OP_2, OP_3, OP_CHECKMULTISIG, SignatureHash, SIGHASH_ALL, SIGVERSION_WITNESS_V0 6from bitcoin.wallet import CBitcoinSecret, CBitcoinAddress, P2WSHBitcoinAddress 78# We\u0026#39;ll be using regtest throughout this guide 9SelectParams(\u0026#34;regtest\u0026#34;) 1011# Create the (in)famous correct brainwallet secret key. 12# first key 13h1 = hashlib.sha256(b\u0026#39;correct horse battery staple first\u0026#39;).digest() 14seckey1 = CBitcoinSecret.from_secret_bytes(h1) 1516# second key 17h2 = hashlib.sha256(b\u0026#39;correct horse battery staple second\u0026#39;).digest() 18seckey2 = CBitcoinSecret.from_secret_bytes(h2) 1920# third key 21h3 = hashlib.sha256(b\u0026#39;correct horse battery staple third\u0026#39;).digest() 22seckey3 = CBitcoinSecret.from_secret_bytes(h2) 2324# Create a witnessScript. witnessScript in SegWit is equivalent to redeemScript in P2SH transaction, 25# however, while the redeemScript of a P2SH transaction is included in the ScriptSig, the  26# WitnessScript is included in the Witness field, making P2WSH inputs cheaper to spend than P2SH  27# inputs. 28witness_script = CScript([OP_2, seckey1.pub, seckey2.pub, seckey3.pub, OP_3, OP_CHECKMULTISIG]) 29script_hash = hashlib.sha256(witness_script).digest() 30script_pubkey = CScript([OP_0, script_hash]) 3132# Convert the P2WSH scriptPubKey to a base58 Bitcoin address and print it. 33# You\u0026#39;ll need to send some funds to it to create a txout to spend. 34address = P2WSHBitcoinAddress.from_scriptPubKey(script_pubkey) 35print(\u0026#39;Address:\u0026#39;, str(address)) 36# outputs: Address: bcrt1qahl75z6ykqwh0sqseqlfvu3z77tzcknwa0pp85f9rrpm33ca8f5qcmgl5s Spend from address (2-of-3) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 23txid = lx(\u0026#34;0acb5f272058c26e5350f1e6f749acdf7233e995f24921d428933817ec46d101\u0026#34;) 4vout = 0 56# Specify the amount send to your P2WSH address. 7amount = int(1 * COIN) 89# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 10# setting on regtest. 11amount_less_fee = amount * 0.99 1213# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 14# is necessary for spending a P2WSH output. 15txin = CMutableTxIn(COutPoint(txid, vout)) 1617# Specify a destination address and create the txout. 18destination = CBitcoinAddress(\u0026#34;bcrt1q0q579hm06qf655cr6ns274udgf6k9x7nedkeaa\u0026#34;).to_scriptPubKey() 19txout = CMutableTxOut(amount_less_fee, destination) 2021# Create the unsigned transaction. 22tx = CMutableTransaction([txin], [txout]) 2324# Calculate the signature hash for that transaction. 25sighash = SignatureHash( 26script=witness_script, 27txTo=tx, 28inIdx=0, 29hashtype=SIGHASH_ALL, 30amount=amount, 31sigversion=SIGVERSION_WITNESS_V0, 32) 3334# Now sign it. We have to append the type of signature we want to the end, in this case the usual 35# SIGHASH_ALL. 36sig2 = seckey2.sign(sighash) + bytes([SIGHASH_ALL]) 37sig3 = seckey3.sign(sighash) + bytes([SIGHASH_ALL]) 3839# Construct a witness for this P2WSH transaction and add to tx. 40witness = CScriptWitness([b\u0026#34;\u0026#34;, *[sig2, sig3], witness_script]) 41tx.wit = CTxWitness([CTxInWitness(witness)]) 4243# Done! Print the transaction 44print(b2x(tx.serialize())) 45# outputs: 0100000000010101d146ec17389328d42149f295e93372dfac49f7e6f150536ec25820275fcb0a0000000000ffffffff01c09ee605000000001600147829e2df6fd013aa5303d4e0af578d4275629bd30400483045022100de73bfd2256b962fffea6c6426f3b2d897986ca227ba1e783ed57cc09339bfc102201b91a0811b3e31e06cd19d569c81cd7e17b9b94919b2f0c28b9cad12efa707c301473044022011a7850fa16e11c9e355005b4f4128fe4896790dbe5af6a6aaa12ea009d833cb02205f38839ab79d61b17bd188c89876e1774f947b25ec201c52c3b045863be46d2001695221038d19497c3922b807c91b829d6873ae5bfa2ae500f3237100265a302fdce87b052103d3a9dff5a0bb0267f19a9ee1c374901c39045fbe041c1c168d4da4ce011259552103d3a9dff5a0bb0267f19a9ee1c374901c39045fbe041c1c168d4da4ce0112595553ae00000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 7805449ea7433df7f9674035fdd88052da2084ecf70ca1285efc3e9b4fd0ea44.\n","link":"https://bitcoinpy.dev/docs/python-bitcoinlib/p2wsh-multisig/","title":"P2WSH address (multisig)"},{"body":" PyPi: https://pypi.org/project/python-bitcoinlib/ Source: GitHub  Python3 library providing an interface to Bitcoin data structures and protocol.\nLibrary supports mainnet, testnet and regtest. A PR for signet has been merged but the version that supports it hasn't been released yet.\n","link":"https://bitcoinpy.dev/docs/python-bitcoinlib/","title":"python-bitcoinlib"},{"body":" PyPi: https://pypi.org/project/buidl/ Source: GitHub  Python3 library with no dependencies. Provides an interface to Bitcoin data structures. There are more functionalities included into this library which are for more advanced use and will be described on this page at later stage.\nLibrary supports mainnet, testnet and signet and requires internet to work.  ","link":"https://bitcoinpy.dev/docs/buidl/","title":"buidl"},{"body":"Generate address 1import hashlib 23from buidl.ecc import PrivateKey, Signature 4from buidl.bech32 import decode_bech32 5from buidl.helper import decode_base58, big_endian_to_int 6from buidl.script import P2PKHScriptPubKey, RedeemScript, WitnessScript, P2WPKHScriptPubKey 7from buidl.tx import Tx, TxIn, TxOut 89h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 10private_key = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 11address = private_key.point.address(network=\u0026#34;signet\u0026#34;) 12print(\u0026#39;Address:\u0026#39;, str(address)) 13# outputs: Address: mrdwvWkma2D6n9mGsbtkazedQQuoksnqJV Spend from address Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 23txid = bytes.fromhex(\u0026#34;06633b187444530eb74284730e45c00946b7f83c4acca5213037e44406b0dceb\u0026#34;) 4vout = 1 56# Specify the amount send to your P2WSH address. 7COIN = 100000000 8amount = int(0.001 * COIN) 910# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 11# setting on regtest. 12amount_less_fee = int(amount * 0.99) 1314# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 15# is necessary for spending a P2WSH output. 16txin = TxIn(txid, vout) 1718# Specify a destination address and create the txout. 19h160 = decode_bech32(\u0026#34;tb1qqqlcpznqkfa65wqd48mzzghpwzefgpvtvl0a7k\u0026#34;)[2] 20txout = TxOut(amount=amount_less_fee, script_pubkey=P2WPKHScriptPubKey(h160)) 2122tx = Tx(1, [txin], [txout], 0, network=\u0026#34;signet\u0026#34;) 2324# Sign the transaction (buidl makes a request to the explorer to fetch public key here) 25tx.sign_p2pkh(0, private_key) 2627# Done! Print the transaction 28print(tx.serialize().hex()) 29# outputs: 0100000001ebdcb00644e4373021a5cc4a3cf8b74609c0450e738442b70e534474183b6306010000006a4730440220026f57ed7143868dba36b4bc3123719a9a4bb65a479ab2e086de9f93e4c43f1c02204943c6e5ead4de886aa1b4777cffa072a21c8d4c13743543d1a4e1f06ab28d0301210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c71ffffffff01b882010000000000160014003f808a60b27baa380da9f62122e170b294058b00000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was ee002c8a2d9a791382600c5e9526faf173c60827abde4f34dd2267d480aa66bd.\n","link":"https://bitcoinpy.dev/docs/buidl/p2pkh/","title":"P2PKH address"},{"body":"Generate address 1import hashlib 23from bitcoin import SelectParams 4from bitcoin.core import b2x, lx, COIN, COutPoint, CMutableTxOut, CMutableTxIn, CMutableTransaction, Hash160 5from bitcoin.core.script import CScript, OP_DUP, OP_HASH160, OP_EQUALVERIFY, OP_CHECKSIG, SignatureHash, SIGHASH_ALL 6from bitcoin.core.scripteval import VerifyScript, SCRIPT_VERIFY_P2SH 7from bitcoin.wallet import CBitcoinAddress, CBitcoinSecret, P2PKHBitcoinAddress 89SelectParams(\u0026#39;regtest\u0026#39;) 1011# Create the (in)famous correct brainwallet secret key. 12h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 13seckey = CBitcoinSecret.from_secret_bytes(h) 1415# Create a redeemScript used to unlock bitcoins 16redeem_script = CScript([OP_DUP, OP_HASH160, Hash160(seckey.pub), OP_EQUALVERIFY, OP_CHECKSIG]) 1718public_key = seckey.pub 19address = P2PKHBitcoinAddress.from_pubkey(public_key) 20print(\u0026#39;Address:\u0026#39;, str(address)) 21# outputs: Address: mrdwvWkma2D6n9mGsbtkazedQQuoksnqJV Spend from address Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 23txid = lx(\u0026#34;c36a4408a242402cb1584e640a5cbe883513a78aae0cf8ea02986cc76845e9e0\u0026#34;) 4vout = 0 56# Specify the amount send to your P2WSH address. 7amount = int(1 * COIN) 89# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 10# setting on regtest. 11amount_less_fee = amount * 0.99 1213# Create the txin structure, which includes the outpoint. The scriptSig 14# defaults to being empty. 15txin = CMutableTxIn(COutPoint(txid, vout)) 1617# Specify a destination address and create the txout. 18destination = CBitcoinAddress(\u0026#39;bcrt1q05cfmjm79ujnnpe2r8wr5kv3kcrtsq3jec3n0l\u0026#39;).to_scriptPubKey() 19txout = CMutableTxOut(amount_less_fee, destination) 2021# Create the unsigned transaction. 22tx = CMutableTransaction([txin], [txout]) 2324# Calculate the signature hash for that transaction. 25sighash = SignatureHash(redeem_script, tx, 0, SIGHASH_ALL) 2627# Now sign it. We have to append the type of signature we want to the end, in 28# this case the usual SIGHASH_ALL. 29sig = seckey.sign(sighash) + bytes([SIGHASH_ALL]) 3031# Set the scriptSig of our transaction input appropriately. 32txin.scriptSig = CScript([sig, seckey.pub]) 3334# Done! Print the transaction 35print(b2x(tx.serialize())) 36# outputs: 0100000001e0e94568c76c9802eaf80cae8aa7133588be5c0a644e58b12c4042a208446ac3000000006b4830450221009abd104d04ecf518c288979ce387defe2ac1d25cb2cf4b3cd97f54e182ef0c3c022055a558c31bcb79237bb75a6659d07eee7875046693818d6f6f0e6064e733c72401210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c71ffffffff01c09ee605000000001600147d309dcb7e2f2539872a19dc3a5991b606b8023200000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was cd6bac96d5f43afaa3663647ed7e7301925ac7760d0d22f1fb7f540a7c080dd7.\n","link":"https://bitcoinpy.dev/docs/python-bitcoinlib/p2pkh/","title":"P2PKH address"},{"body":" PyPi: https://pypi.org/project/bip-utils/ Source: GitHub  This package allows generating mnemonics, seeds, private/public keys and addresses. In particular:\n Mnemonic and seed generation as defined by BIP-0039 Private key encryption/decryption as defined by BIP-0038 Keys derivation as defined by BIP-0032 and SLIP-0010 Derivation of a hierarchy of keys as defined by BIP-0044, BIP-0049 and BIP-0084  This unfortunatelly isn't a Bitcoin only library and includes supports for other cryptocurrencies.\n","link":"https://bitcoinpy.dev/docs/bip-utils/","title":"bip_utils"},{"body":" The example for 1-of-1 should only serve as an example. We don't recommend using it in the real world because it is not its intention. Instead of 1-of-1 use P2PKH!  Generate address (1-of-1) 1import hashlib 23from buidl.ecc import PrivateKey, Signature 4from buidl.bech32 import decode_bech32 5from buidl.helper import decode_base58, big_endian_to_int, SIGHASH_ALL, int_to_byte 6from buidl.script import P2PKHScriptPubKey, RedeemScript, Script, P2WPKHScriptPubKey 7from buidl.tx import Tx, TxIn, TxOut 89h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 10private_key = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 1112# Create a redeemScript. Similar to a scriptPubKey the redeemScript must be satisfied for the funds 13# to be spent. 14redeem_script = RedeemScript([private_key.point.sec(), 0xac]) 15address = redeem_script.address(\u0026#34;signet\u0026#34;) 16print(\u0026#34;Address\u0026#34;, address) 17# outputs: Address: 2Msc7itHhx2x8MEkTthvtED9pFC36J7QpQb Spend from address (1-of-1) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 23txid = bytes.fromhex(\u0026#34;65665709c7d83b7efb8e58f5c6e08a3ebefd752dd83d7af9e0022b13388c3780\u0026#34;) 4vout = 1 56# Specify the amount send to your P2WSH address. 7COIN = 100000000 8amount = int(0.001 * COIN) 910# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 11# setting on regtest. 12amount_less_fee = int(amount * 0.99) 1314# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 15# is necessary for spending a P2WSH output. 16txin = TxIn(txid, vout) 1718# Specify a destination address and create the txout. 19h160 = decode_bech32(\u0026#34;tb1qqqlcpznqkfa65wqd48mzzghpwzefgpvtvl0a7k\u0026#34;)[2] 20txout = TxOut(amount=amount_less_fee, script_pubkey=P2WPKHScriptPubKey(h160)) 2122tx = Tx(1, [txin], [txout], 0, network=\u0026#34;signet\u0026#34;) 2324sighash = tx.sig_hash_legacy(0, redeem_script) 2526# signed sighash 27signed_sighash = private_key.sign(sighash).der() + int_to_byte(SIGHASH_ALL) 2829txin.script_sig = Script([signed_sighash, redeem_script.raw_serialize()]) 3031tx.check_sig_legacy( 320, 33private_key.point, 34Signature.parse(signed_sighash[:-1]), 35redeem_script=redeem_script, 36) 3738# Done! Print the transaction 39print(tx.serialize().hex()) 40# outputs: 010000000180378c38132b02e0f97a3dd82d75fdbe3e8ae0c6f5588efb7e3bd8c709576665010000006c473044022040048e65bb5a58c69d9f514472b5d581f83105422210c134edf20c2ba1d2be50022029069037cc852b83b341a397c0a753bbaf6aefee9e9455483ffaa39666784ad80123210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c71acffffffff01b882010000000000160014003f808a60b27baa380da9f62122e170b294058b00000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 9987191906843b5c99218cbae7f73d0ae85c0b62b78fdaf9755eb6a4a9856858.\nGenerate address (2-of-2) In this example we show how to create a 2-of-2 multisig address. This means that two signatures are required in order to unlock funds.\n1import hashlib 23from buidl.ecc import PrivateKey, Signature 4from buidl.helper import decode_base58, big_endian_to_int 5from buidl.bech32 import decode_bech32, encode_bech32_checksum 6from buidl.script import P2PKHScriptPubKey, RedeemScript, WitnessScript, P2WPKHScriptPubKey 7from buidl.tx import Tx, TxIn, TxOut 8from buidl.witness import Witness 910# first key 11h = hashlib.sha256(b\u0026#39;correct horse battery staple first\u0026#39;).digest() 12private_key1 = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 1314# second key 15h = hashlib.sha256(b\u0026#39;correct horse battery staple second\u0026#39;).digest() 16private_key2 = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 1718# Create a redeem script 19redeem_script = RedeemScript.create_p2sh_multisig( 20quorum_m=2, 21pubkey_hexes=[ 22private_key1.point.sec().hex(), 23private_key2.point.sec().hex(), 24], 25sort_keys=False, 26) 2728address = redeem_script.address(\u0026#34;signet\u0026#34;) 29print(\u0026#39;Address:\u0026#39;, str(address)) 30# outputs: 2N3avDJKpr9c8pkRSYgWAsHSVCmRX3ce3w7 Spend from address (2-of-2) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 23txid = bytes.fromhex(\u0026#34;20a58d3d90b0a9758f2e717dfb4195f270323221b8be01b06c95551807654b9c\u0026#34;) 4vout = 1 56# Specify the amount send to your P2WSH address. 7COIN = 100000000 8amount = int(0.001 * COIN) 910# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 11# setting on regtest. 12amount_less_fee = int(amount * 0.99) 1314# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 15# is necessary for spending a P2WSH output. 16txin = TxIn(txid, vout) 1718# Specify a destination address and create the txout. 19h160 = decode_bech32(\u0026#34;tb1qwp3c26rlgzlq4axergvt04300shexn4f56q5f7\u0026#34;)[2] 20txout = TxOut(amount=amount_less_fee, script_pubkey=P2WPKHScriptPubKey(h160)) 2122tx = Tx(1, [txin], [txout], 0, network=\u0026#34;signet\u0026#34;) 2324sig1 = tx.get_sig_legacy(0, private_key1, redeem_script=redeem_script) 25sig2 = tx.get_sig_legacy(0, private_key2, redeem_script=redeem_script) 2627tx.check_sig_legacy( 280, 29private_key1.point, 30Signature.parse(sig1[:-1]), 31redeem_script=redeem_script, 32) 3334tx.check_sig_legacy( 350, 36private_key2.point, 37Signature.parse(sig2[:-1]), 38redeem_script=redeem_script, 39) 4041txin.finalize_p2sh_multisig([sig1, sig2], redeem_script) 4243print(tx.serialize().hex()) 44# outputs: 01000000019c4b65071855956cb001beb821323270f29541fb7d712e8f75a9b0903d8da52001000000da004730440220470aef78655414f73ca5ae0feec073d49a134ba1bc3b3ea85d2aa864a9735a66022029382bd5f497dc8435f75dff4ebe6cb7205064738487bbfd7099fd3741c61bc901483045022100aa867aeba637ef0aa8f6386e06bcce5010afb081087ab4e3d01ce610f57eaa4702204b50096f8225cac48a93cddab25be1463b160c77605b93556cc215ed83c0d0f301475221038d19497c3922b807c91b829d6873ae5bfa2ae500f3237100265a302fdce87b052103d3a9dff5a0bb0267f19a9ee1c374901c39045fbe041c1c168d4da4ce0112595552aeffffffff01b882010000000000160014706385687f40be0af4d91a18b7d62f7c2f934ea900000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 8439bee332441a97a5bd01396c95353a26a163287e12bd691e1940b734f77478.\nGenerate address (1-of-3) In this example we show how to create a 1-of-3 multisig address. This means that one out of three signatures can unlock and spend bitcoins.\n1import hashlib 23from buidl.ecc import PrivateKey, Signature 4from buidl.helper import decode_base58, big_endian_to_int 5from buidl.bech32 import decode_bech32, encode_bech32_checksum 6from buidl.script import P2PKHScriptPubKey, RedeemScript, WitnessScript, P2WPKHScriptPubKey 7from buidl.tx import Tx, TxIn, TxOut 8from buidl.witness import Witness 910# first key 11h = hashlib.sha256(b\u0026#39;correct horse battery staple first\u0026#39;).digest() 12private_key1 = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 1314# second key 15h = hashlib.sha256(b\u0026#39;correct horse battery staple second\u0026#39;).digest() 16private_key2 = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 1718# third key 19h = hashlib.sha256(b\u0026#39;correct horse battery staple third\u0026#39;).digest() 20private_key3 = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 2122# Create a redeem script 23redeem_script = RedeemScript.create_p2sh_multisig( 24quorum_m=1, # how many signatures are required 25pubkey_hexes=[ 26private_key1.point.sec().hex(), 27private_key2.point.sec().hex(), 28private_key3.point.sec().hex(), 29], 30sort_keys=False, 31) 3233address = redeem_script.address(\u0026#34;signet\u0026#34;) 34print(\u0026#39;Address:\u0026#39;, str(address)) 35# outputs: 2N5LksNHu7mL8EjjgXiqDoebL1Sft18ZGJs Spend from address (1-of-3) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 23txid = bytes.fromhex(\u0026#34;b82897726ee94a0ffe019bcbc8ff22e5c9d5207659807bb5dec84a3722901175\u0026#34;) 4vout = 1 56# Specify the amount send to your P2WSH address. 7COIN = 100000000 8amount = int(0.001 * COIN) 910# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 11# setting on regtest. 12amount_less_fee = int(amount * 0.99) 1314# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 15# is necessary for spending a P2WSH output. 16txin = TxIn(txid, vout) 1718# Specify a destination address and create the txout. 19h160 = decode_bech32(\u0026#34;tb1qwp3c26rlgzlq4axergvt04300shexn4f56q5f7\u0026#34;)[2] 20txout = TxOut(amount=amount_less_fee, script_pubkey=P2WPKHScriptPubKey(h160)) 2122tx = Tx(1, [txin], [txout], 0, network=\u0026#34;signet\u0026#34;) 2324sig2 = tx.get_sig_legacy(0, private_key2, redeem_script=redeem_script) 2526tx.check_sig_legacy( 270, 28private_key2.point, 29Signature.parse(sig2[:-1]), 30redeem_script=redeem_script, 31) 3233# we will finalize this transaction using the second signature 34txin.finalize_p2sh_multisig([sig2], redeem_script) 3536print(tx.serialize().hex()) 37# outputs: 010000000175119022374ac8deb57b80597620d5c9e522ffc8cb9b01fe0f4ae96e729728b801000000b40047304402201faabc28b75db74f2cff5137eb278a26693106304835d129e6bc9522f463fcd90220613987ed01655781cca27f762e58222fa006d5161804f10a7ab8b04104c25aee014c695121038d19497c3922b807c91b829d6873ae5bfa2ae500f3237100265a302fdce87b052103d3a9dff5a0bb0267f19a9ee1c374901c39045fbe041c1c168d4da4ce01125955210228769768e3083e084dd5c03b6077d51b7e7a22bd66fc99ff481dcf9b6b80d03053aeffffffff01b882010000000000160014706385687f40be0af4d91a18b7d62f7c2f934ea900000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 7ad8a4df0b38eab28b21e43950ce5243d3dbdf92a209620b5bffb07ec7417d18.\nGenerate address (2-of-3) In this example we show how to create a 2-of-3 multisig address. This means that two out of three signatures can unlock and spend bitcoins.\n1import hashlib 23from buidl.ecc import PrivateKey, Signature 4from buidl.helper import decode_base58, big_endian_to_int 5from buidl.bech32 import decode_bech32, encode_bech32_checksum 6from buidl.script import P2PKHScriptPubKey, RedeemScript, WitnessScript, P2WPKHScriptPubKey 7from buidl.tx import Tx, TxIn, TxOut 8from buidl.witness import Witness 910# first key 11h = hashlib.sha256(b\u0026#39;correct horse battery staple first\u0026#39;).digest() 12private_key1 = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 1314# second key 15h = hashlib.sha256(b\u0026#39;correct horse battery staple second\u0026#39;).digest() 16private_key2 = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 1718# third key 19h = hashlib.sha256(b\u0026#39;correct horse battery staple third\u0026#39;).digest() 20private_key3 = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 2122# Create a redeem script 23redeem_script = RedeemScript.create_p2sh_multisig( 24quorum_m=2, # how many signatures are required 25pubkey_hexes=[ 26private_key1.point.sec().hex(), 27private_key2.point.sec().hex(), 28private_key3.point.sec().hex(), 29], 30sort_keys=False, 31) 3233address = redeem_script.address(\u0026#34;signet\u0026#34;) 34print(\u0026#39;Address:\u0026#39;, str(address)) 35# outputs: 2MyaZGLLZsEjRrnJQ3pAuNUNb9NhQnF1UhP Spend from address (2-of-3) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 23txid = bytes.fromhex(\u0026#34;cc75da80c0702fdd340c75b8b7f430b914eaf1ba048055815303ee4ebcebc45f\u0026#34;) 4vout = 0 56# Specify the amount send to your P2WSH address. 7COIN = 100000000 8amount = int(0.001 * COIN) 910# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 11# setting on regtest. 12amount_less_fee = int(amount * 0.99) 1314# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 15# is necessary for spending a P2WSH output. 16txin = TxIn(txid, vout) 1718# Specify a destination address and create the txout. 19h160 = decode_bech32(\u0026#34;tb1qwp3c26rlgzlq4axergvt04300shexn4f56q5f7\u0026#34;)[2] 20txout = TxOut(amount=amount_less_fee, script_pubkey=P2WPKHScriptPubKey(h160)) 2122tx = Tx(1, [txin], [txout], 0, network=\u0026#34;signet\u0026#34;) 2324sig2 = tx.get_sig_legacy(0, private_key2, redeem_script=redeem_script) 25sig3 = tx.get_sig_legacy(0, private_key3, redeem_script=redeem_script) 2627tx.check_sig_segwit( 280, 29private_key1.point, 30Signature.parse(sig1[:-1]), 31redeem_script=redeem_script, 32) 3334tx.check_sig_legacy( 350, 36private_key2.point, 37Signature.parse(sig2[:-1]), 38redeem_script=redeem_script, 39) 40tx.check_sig_legacy( 410, 42private_key3.point, 43Signature.parse(sig3[:-1]), 44redeem_script=redeem_script, 45) 4647# we will finalize this transaction using the second signature 48txin.finalize_p2sh_multisig([sig2, sig3], redeem_script) 4950print(tx.serialize().hex()) 51# outputs: 01000000015fc4ebbc4eee035381558004baf1ea14b930f4b7b8750c34dd2f70c080da75cc00000000fc00473044022007c7275dfa45242e72946adf892e38047a8b69bb5760a5c382ede8a04aeec859022072ac719796ce469693c14fb45e03064be1644df65e6f58c45face48bfd9b4352014730440220778bd0deb867907b05f509a23a22d597587ee1eeb3e01000892909a270fbb9d20220665779c669da7fd1aeb04c70ba0fef853bd08f35625f34e98b883eb22381ace9014c695221038d19497c3922b807c91b829d6873ae5bfa2ae500f3237100265a302fdce87b052103d3a9dff5a0bb0267f19a9ee1c374901c39045fbe041c1c168d4da4ce01125955210228769768e3083e084dd5c03b6077d51b7e7a22bd66fc99ff481dcf9b6b80d03053aeffffffff01b882010000000000160014706385687f40be0af4d91a18b7d62f7c2f934ea900000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 1bbdfcf560c1b105aecc5a4a63eb0b6390aa5e2d90667f9c1aa318a12702be46.\n","link":"https://bitcoinpy.dev/docs/buidl/p2sh-multisig/","title":"P2SH address (multisig)"},{"body":" The example for 1-of-1 should only serve as an example. We don't recommend using it in the real world because it is not its intention. Instead of 1-of-1 use P2PKH!  Generate address (1-of-1) 1import hashlib 23from bitcoin import SelectParams 4from bitcoin.core import b2x, lx, COIN, COutPoint, CMutableTxOut, CMutableTxIn, CMutableTransaction, Hash160 5from bitcoin.core.script import CScript, OP_DUP, OP_HASH160, OP_EQUALVERIFY, OP_CHECKSIG, SignatureHash, SIGHASH_ALL 6from bitcoin.core.scripteval import VerifyScript, SCRIPT_VERIFY_P2SH 7from bitcoin.wallet import CBitcoinAddress, CBitcoinSecret 89SelectParams(\u0026#39;regtest\u0026#39;) 1011# Create the (in)famous correct brainwallet secret key. 12h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 13seckey = CBitcoinSecret.from_secret_bytes(h) 1415# Create a redeemScript. Similar to a scriptPubKey the redeemScript must be 16# satisfied for the funds to be spent. 17redeem_script = CScript([seckey.pub, OP_CHECKSIG]) 1819# Create the magic P2SH scriptPubKey format from that redeemScript. You should 20# look at the CScript.to_p2sh_scriptPubKey() function in bitcoin.core.script to 21# understand what\u0026#39;s happening, as well as read BIP16: 22# https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki 23script_pubkey = redeem_script.to_p2sh_scriptPubKey() 2425# Convert the P2SH scriptPubKey to a base58 Bitcoin address and print it. 26# You\u0026#39;ll need to send some funds to it to create a txout to spend. 27address = CBitcoinAddress.from_scriptPubKey(script_pubkey) 28print(\u0026#39;Address:\u0026#39;,str(address)) 29# outputs: Address: 2Msc7itHhx2x8MEkTthvtED9pFC36J7QpQb Spend from address (1-of-1) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 23txid = lx(\u0026#34;600bb0135fa78bbf895b5a933bbff0c304f66ba74810cb9f533e358ded2663c5\u0026#34;) 4vout = 1 56# Specify the amount send to your P2WSH address. 7amount = int(1 * COIN) 89# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 10# setting on regtest. 11amount_less_fee = amount * 0.99 1213# Create the txin structure, which includes the outpoint. The scriptSig 14# defaults to being empty. 15txin = CMutableTxIn(COutPoint(txid, vout)) 1617# Specify a destination address and create the txout. 18destination = CBitcoinAddress(\u0026#34;bcrt1qzw44fxmxs2y39uxtl9ql0sxwpspwd0p8rum3nw\u0026#34;).to_scriptPubKey() 19txout = CMutableTxOut(amount_less_fee, destination) 2021# Create the unsigned transaction. 22tx = CMutableTransaction([txin], [txout]) 2324# Calculate the signature hash for that transaction. Note how the script we use 25# is the redeemScript, not the scriptPubKey. That\u0026#39;s because when the CHECKSIG 26# operation happens EvalScript() will be evaluating the redeemScript, so the 27# corresponding SignatureHash() function will use that same script when it 28# replaces the scriptSig in the transaction being hashed with the script being 29# executed. 30sighash = SignatureHash(redeem_script, tx, 0, SIGHASH_ALL) 3132# Now sign it. We have to append the type of signature we want to the end, in 33# this case the usual SIGHASH_ALL. 34sig = seckey.sign(sighash) + bytes([SIGHASH_ALL]) 3536# Set the scriptSig of our transaction input appropriately. 37txin.scriptSig = CScript([sig, redeem_script]) 3839# Done! Print the transaction 40print(b2x(tx.serialize())) 41# outputs: 0100000001c56326ed8d353e539fcb1048a76bf604c3f0bf3b935a5b89bf8ba75f13b00b60010000006d483045022100ec13f326674bc6accef9aa8ec7101d1301d8e33af86fc5737c04d66bf6beaa000220095d38069dc8563edfcfb52c36b7b8334d3c76d4ab07fdcd9635bfaf67b19ba60123210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c71acffffffff01c09ee6050000000016001413ab549b66828912f0cbf941f7c0ce0c02e6bc2700000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 5cf00f81103b8b0283d98cec2f20421496eba6cc0660b263275e06f142686650.\nGenerate address (2-of-2) In this example we show how to create a 2-of-2 multisig address. This means that two signatures are required in order to unlock funds.\n1import hashlib 23from bitcoin import SelectParams 4from bitcoin.core import b2x, lx, COIN, COutPoint, CMutableTxOut, CMutableTxIn, CMutableTransaction, Hash160 5from bitcoin.core.script import CScript, OP_DUP, OP_0, OP_2, OP_HASH160, OP_EQUALVERIFY, OP_CHECKMULTISIG, SignatureHash, SIGHASH_ALL 6from bitcoin.core.scripteval import VerifyScript, SCRIPT_VERIFY_P2SH 7from bitcoin.wallet import CBitcoinAddress, CBitcoinSecret 89SelectParams(\u0026#39;regtest\u0026#39;) 1011# first key 12h1 = hashlib.sha256(b\u0026#39;correct horse battery staple first\u0026#39;).digest() 13seckey1 = CBitcoinSecret.from_secret_bytes(h1) 1415# second key 16h2 = hashlib.sha256(b\u0026#39;correct horse battery staple second\u0026#39;).digest() 17seckey2 = CBitcoinSecret.from_secret_bytes(h2) 1819# Create a redeemScript. Similar to a scriptPubKey the redeemScript must be 20# satisfied for the funds to be spent. 21redeem_script = CScript([OP_2, seckey1.pub, seckey2.pub, OP_2, OP_CHECKMULTISIG]) 2223# Create the magic P2SH scriptPubKey format from that redeemScript. You should 24# look at the CScript.to_p2sh_scriptPubKey() function in bitcoin.core.script to 25# understand what\u0026#39;s happening, as well as read BIP16: 26# https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki 27script_pubkey = redeem_script.to_p2sh_scriptPubKey() 2829# Convert the P2SH scriptPubKey to a base58 Bitcoin address and print it. 30# You\u0026#39;ll need to send some funds to it to create a txout to spend. 31address = CBitcoinAddress.from_scriptPubKey(script_pubkey) 32print(\u0026#39;Address:\u0026#39;,str(address)) 33# outputs: Address: 2N3avDJKpr9c8pkRSYgWAsHSVCmRX3ce3w7 Spend from address (2-of-2) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 23txid = lx(\u0026#34;55a7cdebf307597fade5327daa6c95bcab6abc200a878ec191c1f3bd0b7664d0\u0026#34;) 4vout = 0 56# Specify the amount send to your P2WSH address. 7amount = int(1 * COIN) 89# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 10# setting on regtest. 11amount_less_fee = amount * 0.99 1213# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 14# is necessary for spending a P2WSH output. 15txin = CMutableTxIn(COutPoint(txid, vout)) 1617# Specify a destination address and create the txout. 18destination = CBitcoinAddress(\u0026#34;bcrt1q0q579hm06qf655cr6ns274udgf6k9x7nedkeaa\u0026#34;).to_scriptPubKey() 19txout = CMutableTxOut(amount_less_fee, destination) 2021# Create the unsigned transaction. 22tx = CMutableTransaction([txin], [txout]) 2324# Calculate the signature hash for that transaction. 25sighash = SignatureHash( 26script=redeem_script, 27txTo=tx, 28inIdx=0, 29hashtype=SIGHASH_ALL, 30amount=amount, 31) 3233# Now sign it. We have to append the type of signature we want to the end, in this case the usual 34# SIGHASH_ALL. 35sig1 = seckey1.sign(sighash) + bytes([SIGHASH_ALL]) 36sig2 = seckey2.sign(sighash) + bytes([SIGHASH_ALL]) 3738# Construct a witness for this P2WSH transaction and add to tx. 39txin.scriptSig = CScript([OP_0, sig1, sig2, redeem_script]) 4041# Done! Print the transaction 42print(b2x(tx.serialize())) 43# outputs: 0100000001d064760bbdf3c191c18e870a20bc6aabbc956caa7d32e5ad7f5907f3ebcda75500000000db00483045022100a22bf0495398d87538bb07daf62948572def31d411df6048e92a53b00d35f06c02204583f20a0fcbb6f5a978f32dde6dfadfe11581973eef946bb87e1ce5b164fb3a014830450221008611aacb5ab9efb1f64200800ac8f55bb6a1acbcdaa2d3db7741df6b99c9f6f802202be1a1c4fdcb649f622b25ad88befba4ef23689e07409bffd4a1d63237993dbd01475221038d19497c3922b807c91b829d6873ae5bfa2ae500f3237100265a302fdce87b052103d3a9dff5a0bb0267f19a9ee1c374901c39045fbe041c1c168d4da4ce0112595552aeffffffff01c09ee605000000001600147829e2df6fd013aa5303d4e0af578d4275629bd300000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 844dd295da6877b8e7b01fa79f46aedf1b4f21651c0210ebf5e36f2476f2116d.\nGenerate address (1-of-3) In this example we show how to create a 1-of-3 multisig address. This means that one out of three signatures can unlock and spend bitcoins.\n1import hashlib 23from bitcoin import SelectParams 4from bitcoin.core import b2x, lx, COIN, COutPoint, CMutableTxOut, CMutableTxIn, CMutableTransaction, Hash160 5from bitcoin.core.script import CScript, OP_DUP, OP_0, OP_1, OP_3, OP_HASH160, OP_EQUALVERIFY, OP_CHECKMULTISIG, SignatureHash, SIGHASH_ALL 6from bitcoin.core.scripteval import VerifyScript, SCRIPT_VERIFY_P2SH 7from bitcoin.wallet import CBitcoinAddress, CBitcoinSecret 89SelectParams(\u0026#39;regtest\u0026#39;) 1011# first key 12h1 = hashlib.sha256(b\u0026#39;correct horse battery staple first\u0026#39;).digest() 13seckey1 = CBitcoinSecret.from_secret_bytes(h1) 1415# second key 16h2 = hashlib.sha256(b\u0026#39;correct horse battery staple second\u0026#39;).digest() 17seckey2 = CBitcoinSecret.from_secret_bytes(h2) 1819# third key 20h3 = hashlib.sha256(b\u0026#39;correct horse battery staple third\u0026#39;).digest() 21seckey3 = CBitcoinSecret.from_secret_bytes(h2) 2223# Create a redeemScript. Similar to a scriptPubKey the redeemScript must be 24# satisfied for the funds to be spent. 25redeem_script = CScript([OP_1, seckey1.pub, seckey2.pub, seckey3.pub, OP_3, OP_CHECKMULTISIG]) 2627# Create the magic P2SH scriptPubKey format from that redeemScript. You should 28# look at the CScript.to_p2sh_scriptPubKey() function in bitcoin.core.script to 29# understand what\u0026#39;s happening, as well as read BIP16: 30# https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki 31script_pubkey = redeem_script.to_p2sh_scriptPubKey() 3233# Convert the P2SH scriptPubKey to a base58 Bitcoin address and print it. 34# You\u0026#39;ll need to send some funds to it to create a txout to spend. 35address = CBitcoinAddress.from_scriptPubKey(script_pubkey) 36print(\u0026#39;Address:\u0026#39;,str(address)) 37# outputs: Address: 2MzB7ZEastmRyWMdY54fMxRXu3Wf9iu47AE Spend from address (1-of-3) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 23txid = lx(\u0026#34;8e46a443d5877e21d83cc519cb22dde72e29884e91c4fb3410afa2cf1cb8b03c\u0026#34;) 4vout = 0 56# Specify the amount send to your P2WSH address. 7amount = int(1 * COIN) 89# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 10# setting on regtest. 11amount_less_fee = amount * 0.99 1213# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 14# is necessary for spending a P2WSH output. 15txin = CMutableTxIn(COutPoint(txid, vout)) 1617# Specify a destination address and create the txout. 18destination = CBitcoinAddress(\u0026#34;bcrt1q0q579hm06qf655cr6ns274udgf6k9x7nedkeaa\u0026#34;).to_scriptPubKey() 19txout = CMutableTxOut(amount_less_fee, destination) 2021# Create the unsigned transaction. 22tx = CMutableTransaction([txin], [txout]) 2324# Calculate the signature hash for that transaction. 25sighash = SignatureHash( 26script=redeem_script, 27txTo=tx, 28inIdx=0, 29hashtype=SIGHASH_ALL, 30amount=amount, 31) 3233# Now sign it. We have to append the type of signature we want to the end, in this case the usual 34# SIGHASH_ALL. 35sig2 = seckey2.sign(sighash) + bytes([SIGHASH_ALL]) 3637# Construct a witness for this P2WSH transaction and add to tx. 38txin.scriptSig = CScript([OP_0, sig2, redeem_script]) 3940# Done! Print the transaction 41print(b2x(tx.serialize())) 42# outputs: 01000000013cb0b81ccfa2af1034fbc4914e88292ee7dd22cb19c53cd8217e87d543a4468e00000000b4004730440220437bc4b0a8c600de2cbbd57f14a60c0737c680e7cabc25217bb9a61950b55214022027bfc9d4bf0cc2ea88d416e877a54b8841483b1c18633c8732186d4333049e64014c695121038d19497c3922b807c91b829d6873ae5bfa2ae500f3237100265a302fdce87b052103d3a9dff5a0bb0267f19a9ee1c374901c39045fbe041c1c168d4da4ce011259552103d3a9dff5a0bb0267f19a9ee1c374901c39045fbe041c1c168d4da4ce0112595553aeffffffff01c09ee605000000001600147829e2df6fd013aa5303d4e0af578d4275629bd300000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was afb52d8ca23ef7b98444845258018905360cf635c7e8b19bb1a541f74a8f3124.\nGenerate address (2-of-3) In this example we show how to create a 2-of-3 multisig address. This means that two out of three signatures can unlock and spend bitcoins.\n1import hashlib 23from bitcoin import SelectParams 4from bitcoin.core import b2x, lx, COIN, COutPoint, CMutableTxOut, CMutableTxIn, CMutableTransaction, Hash160 5from bitcoin.core.script import CScript, OP_DUP, OP_0, OP_2, OP_3, OP_HASH160, OP_EQUALVERIFY, OP_CHECKMULTISIG, SignatureHash, SIGHASH_ALL 6from bitcoin.core.scripteval import VerifyScript, SCRIPT_VERIFY_P2SH 7from bitcoin.wallet import CBitcoinAddress, CBitcoinSecret 89SelectParams(\u0026#39;regtest\u0026#39;) 1011# first key 12h1 = hashlib.sha256(b\u0026#39;correct horse battery staple first\u0026#39;).digest() 13seckey1 = CBitcoinSecret.from_secret_bytes(h1) 1415# second key 16h2 = hashlib.sha256(b\u0026#39;correct horse battery staple second\u0026#39;).digest() 17seckey2 = CBitcoinSecret.from_secret_bytes(h2) 1819# third key 20h3 = hashlib.sha256(b\u0026#39;correct horse battery staple third\u0026#39;).digest() 21seckey3 = CBitcoinSecret.from_secret_bytes(h2) 2223# Create a redeemScript. Similar to a scriptPubKey the redeemScript must be 24# satisfied for the funds to be spent. 25redeem_script = CScript([OP_2, seckey1.pub, seckey2.pub, seckey3.pub, OP_3, OP_CHECKMULTISIG]) 2627# Create the magic P2SH scriptPubKey format from that redeemScript. You should 28# look at the CScript.to_p2sh_scriptPubKey() function in bitcoin.core.script to 29# understand what\u0026#39;s happening, as well as read BIP16: 30# https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki 31script_pubkey = redeem_script.to_p2sh_scriptPubKey() 3233# Convert the P2SH scriptPubKey to a base58 Bitcoin address and print it. 34# You\u0026#39;ll need to send some funds to it to create a txout to spend. 35address = CBitcoinAddress.from_scriptPubKey(script_pubkey) 36print(\u0026#39;Address:\u0026#39;,str(address)) 37# outputs: Address: 2MuHBt425GsVo1wXnoN3mvCzdMRFf7HnvJV Spend from address (2-of-3) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 23txid = lx(\u0026#34;e2d5767f90a0129292baf11ec440824860a0b065becfab433dc6c66e19b4abb6\u0026#34;) 4vout = 1 56# Specify the amount send to your P2WSH address. 7amount = int(1 * COIN) 89# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 10# setting on regtest. 11amount_less_fee = amount * 0.99 1213# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 14# is necessary for spending a P2WSH output. 15txin = CMutableTxIn(COutPoint(txid, vout)) 1617# Specify a destination address and create the txout. 18destination = CBitcoinAddress(\u0026#34;bcrt1q0q579hm06qf655cr6ns274udgf6k9x7nedkeaa\u0026#34;).to_scriptPubKey() 19txout = CMutableTxOut(amount_less_fee, destination) 2021# Create the unsigned transaction. 22tx = CMutableTransaction([txin], [txout]) 2324# Calculate the signature hash for that transaction. 25sighash = SignatureHash( 26script=redeem_script, 27txTo=tx, 28inIdx=0, 29hashtype=SIGHASH_ALL, 30amount=amount, 31) 3233# Now sign it. We have to append the type of signature we want to the end, in this case the usual 34# SIGHASH_ALL. 35sig2 = seckey2.sign(sighash) + bytes([SIGHASH_ALL]) 36sig3 = seckey3.sign(sighash) + bytes([SIGHASH_ALL]) 3738# Construct a witness for this P2WSH transaction and add to tx. 39txin.scriptSig = CScript([OP_0, sig2, sig3, redeem_script]) 4041# Done! Print the transaction 42print(b2x(tx.serialize())) 43# outputs: 0100000001b6abb4196ec6c63d43abcfbe65b0a060488240c41ef1ba929212a0907f76d5e201000000fdfe0000483045022100806e36bc310c0ed942e9ec979407dc0981340d304ec058e8e2aed4c74af34af202201eafaf6392f8f58d5f80b9fe621fd6cea1bfd8db5d427080152ee9f3e2c2899701483045022100ad999b0c72368ea7e83dd25286d2289e0da38247f1a05fab90c1a48d1879934202201e3bdcdb1f2528bd4f2a8ffd6eadf1aef36e934160f709a713af54a8e376d7c1014c695221038d19497c3922b807c91b829d6873ae5bfa2ae500f3237100265a302fdce87b052103d3a9dff5a0bb0267f19a9ee1c374901c39045fbe041c1c168d4da4ce011259552103d3a9dff5a0bb0267f19a9ee1c374901c39045fbe041c1c168d4da4ce0112595553aeffffffff01c09ee605000000001600147829e2df6fd013aa5303d4e0af578d4275629bd300000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 11c69b64290a67e95f7148b1e399db89ab98982a18f3dc02ed408f90b66158ea.\n","link":"https://bitcoinpy.dev/docs/python-bitcoinlib/p2sh-multisig/","title":"P2SH address (multisig)"},{"body":"Hash Time Locked Contract (HTLC) is a conditional payment that can be spent in two ways. Either sender (the person who locked the funds in) can unlock them after some number of blocks have been mined or the receiver (the person whom the funds are intended for) when he gets reveald the secret code that only sender knows.\nNote that each condition also runs a OP_EQUALVERIFY check on a public key to enforce that:\n only the sender can spend after X amount of blocks are mined only the recipient can spend if he knows the secret (sender or anyone else can not spend these coins if they know the secret)  HTLC are used in Lightning Network, atomic swaps, same-chain coin swaps and other advanced protocols.\nThere are different ways of how HTLC's can be constructed and bellow example is just one of the way and not necesseraly the best way. For example OP_CHECKLOCKTIMEVERIFY would better ber replaced with OP_CSV, and the script itself could be optimized to be smaller in size.\nGenerate address 1import hashlib 23from bitcoin import SelectParams 4from bitcoin.core import b2x, x, lx, COIN, COutPoint, CMutableTxOut, CMutableTxIn, CMutableTransaction, Hash160, CScriptWitness, CTxInWitness, CTxWitness 5from bitcoin.core.script import CScript, OP_0, OP_IF, OP_ELSE, OP_SHA256, OP_DUP, OP_HASH160, OP_EQUALVERIFY, OP_CHECKLOCKTIMEVERIFY, OP_CHECKSIG, SignatureHash, SIGHASH_ALL, OP_DROP, OP_ENDIF, SIGVERSION_WITNESS_V0 6from bitcoin.wallet import CBitcoinAddress, CBitcoinSecret, P2WSHBitcoinAddress 78SelectParams(\u0026#39;regtest\u0026#39;) 910# addresses generate via bitcoin-cli public key and private key were fetched using bitcoin-cli commands: `getaddressinfo` and `dumpprivkey` 11# 1. (sender): bcrt1qz52gzlzcesun0cy4v8u5k6uwrjmqayhvf0w806 (03d28046cd12e83832cca3fc4428d254e60092e06fa3f3b8de32062c1b07f58976) 12# 2. (recipient): bcrt1q3qk7a5d2963feda6d6lrrvrvsnp05zlzasme8f (02743d0627a342afdcd7b1577d4d175f0c5206bc3da193bfecd5594b2eba1d256c) 1314# private key for recipient bcrt1q3qk7a5d2963feda6d6lrrvrvsnp05zlzasme8f (generated via bitcoin-cli) 15private_key_recipient = \u0026#34;cR6XDAkF7urxoX3PioYfWwCB5MJTVuCNTdeUc5t2nceKPL2nBmfJ\u0026#34; 16seckey_recipient = CBitcoinSecret(private_key_recipient) 1718# private key for sender bcrt1qz52gzlzcesun0cy4v8u5k6uwrjmqayhvf0w806 (generated via bitcoin-cli) 19private_key_sender = \u0026#34;cNQREEPKSd7ugdCMAQNEedNpYhGrgXiqfyWSt4H7jfm722FWFz2V\u0026#34; 20seckey_sender = CBitcoinSecret(private_key_sender) 2122# secret and preimage 23secret = b\u0026#34;super secret code\u0026#34; 24preimage = hashlib.sha256(secret).digest() 2526lockduration = 5 # in 5 blocks 27current_blocknum = 274 # current number of blocks 28redeem_blocknum = current_blocknum + lockduration 29recipientpubkey = x(\u0026#34;02743d0627a342afdcd7b1577d4d175f0c5206bc3da193bfecd5594b2eba1d256c\u0026#34;) 30senderpubkey = x(\u0026#34;03d28046cd12e83832cca3fc4428d254e60092e06fa3f3b8de32062c1b07f58976\u0026#34;) 3132# Create a htlc script where in order to spend either of the two conditions need to be met: 33# 1. recipient can claim funds by providing a secret 34# 2. sender can claim funds after X blocks have been mined 35witness_script = CScript([ 36OP_IF, 37OP_SHA256, preimage, OP_EQUALVERIFY, OP_DUP, OP_HASH160, Hash160(recipientpubkey), 38OP_ELSE, 39redeem_blocknum, OP_CHECKLOCKTIMEVERIFY, OP_DROP, OP_DUP, OP_HASH160, Hash160(senderpubkey), 40OP_ENDIF, 41OP_EQUALVERIFY, 42OP_CHECKSIG, 43]) 4445script_hash = hashlib.sha256(witness_script).digest() 46script_pubkey = CScript([OP_0, script_hash]) 47address = P2WSHBitcoinAddress.from_scriptPubKey(script_pubkey) 48print(\u0026#39;Address:\u0026#39;, str(address)) 49# Address: bcrt1q5xpn8y8hlkf5nqc2sqkph64qmj0exf6cwtlqknf34y9s4ejga2zs3f2m9s Spend from address (via secret) In this example we will spend the funds by using the secret.\n1# we are continuing the code from above 23txid = lx(\u0026#34;2c3759145da44e8a75d24e3535f643de4e28fb85e9f779fa1d0255c7f8b17729\u0026#34;) 4vout = 0 56# Specify the amount send to your P2WSH address. 7amount = int(1 * COIN) 89# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 10# setting on regtest. 11amount_less_fee = amount * 0.99 1213# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 14# is necessary for spending a P2WSH output. 15txin = CMutableTxIn(COutPoint(txid, vout)) 1617# Specify a destination address and create the txout. 18destination = CBitcoinAddress(\u0026#34;bcrt1q3qk7a5d2963feda6d6lrrvrvsnp05zlzasme8f\u0026#34;).to_scriptPubKey() 19txout = CMutableTxOut(amount_less_fee, destination) 2021# Create the unsigned transaction. 22tx = CMutableTransaction([txin], [txout]) 2324# Calculate the signature hash for that transaction. 25sighash = SignatureHash( 26script=witness_script, 27txTo=tx, 28inIdx=0, 29hashtype=SIGHASH_ALL, 30amount=amount, 31sigversion=SIGVERSION_WITNESS_V0, 32) 3334# Now sign it. We have to append the type of signature we want to the end, in this case the usual 35# SIGHASH_ALL. 36sig = seckey_recipient.sign(sighash) + bytes([SIGHASH_ALL]) 3738# Construct a witness for this P2WSH transaction and add to tx. 39witness = CScriptWitness([sig, seckey_recipient.pub, secret, b\u0026#39;\\x01\u0026#39;, witness_script]) 40tx.wit = CTxWitness([CTxInWitness(witness)]) 4142# Done! Print the transaction 43print(b2x(tx.serialize())) 44# outputs: 010000000001012977b1f8c755021dfa79f7e985fb284ede43f635354ed2758a4ea45d1459372c0000000000ffffffff01c09ee60500000000160014882deed1aa2ea29cb7ba6ebe31b06c84c2fa0be205473044022023b1482fb9e119eaac4c623ded42aece99b468d39f6a0a2a21bdb0320a9f2a770220237b99c6063061ae72dd4b39b9fb6390a3f070cdb2b7dee936a8cb0f359cdb7f012102743d0627a342afdcd7b1577d4d175f0c5206bc3da193bfecd5594b2eba1d256c1173757065722073656372657420636f646501015b63a8206bd66227651d0fe5c43863d7b29a4097e31dbf51e6603eee75947bff5e96ae438876a914882deed1aa2ea29cb7ba6ebe31b06c84c2fa0be267021701b17576a9141514817c58cc3937e09561f94b6b8e1cb60e92ec6888ac00000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was fbf084eece2f14a017eabfe7fd7db3ee42f0245560a851f39cf34131caabfcb7.\nSpend from address (after timeout) In this example we will spend the funds after X blocks have been mined.\n1# we are continuing the code from above 23txid = lx(\u0026#34;1f55451b6fe0d839ada38724d00a94118afedaf6564e492887493e3c9dd0dca4\u0026#34;) 4vout = 0 56# Specify the amount send to your P2WSH address. 7amount = int(1 * COIN) 89# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 10# setting on regtest. 11amount_less_fee = amount * 0.99 1213# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 14# is necessary for spending a P2WSH output. 15txin = CMutableTxIn(COutPoint(txid, vout)) 1617# Specify a destination address and create the txout. 18destination = CBitcoinAddress(\u0026#34;bcrt1q3qk7a5d2963feda6d6lrrvrvsnp05zlzasme8f\u0026#34;).to_scriptPubKey() 19txout = CMutableTxOut(amount_less_fee, destination) 2021# The default nSequence of FFFFFFFF won\u0026#39;t let you redeem when there\u0026#39;s a CHECKTIMELOCKVERIFY 22txin.nSequence = 0 2324# Create the unsigned transaction. 25tx = CMutableTransaction([txin], [txout]) 2627# nLockTime needs to be at least as large as parameter of CHECKLOCKTIMEVERIFY for script to verify 28tx.nLockTime = redeem_blocknum 2930# Calculate the signature hash for that transaction. 31sighash = SignatureHash( 32script=witness_script, 33txTo=tx, 34inIdx=0, 35hashtype=SIGHASH_ALL, 36amount=amount, 37sigversion=SIGVERSION_WITNESS_V0, 38) 3940# Now sign it. We have to append the type of signature we want to the end, in this case the usual 41# SIGHASH_ALL. 42sig = seckey_sender.sign(sighash) + bytes([SIGHASH_ALL]) 4344# Construct a witness for this P2WSH transaction and add to tx. 45witness = CScriptWitness([sig, seckey_sender.pub, b\u0026#39;\u0026#39;, witness_script]) 46tx.wit = CTxWitness([CTxInWitness(witness)]) 4748# Done! Print the transaction 49print(b2x(tx.serialize())) 50# outputs: 010000000001015f8d477e52c7c4338952a9a8a053d682ff42023097e54df102d47f477f3e274900000000000000000001c09ee60500000000160014882deed1aa2ea29cb7ba6ebe31b06c84c2fa0be204483045022100befaddac4d23e7a5edcf5847e6f5cc127021ebc34719b32680bc040aeece5b7402204736e36df03142e7c0573e6d2e9f44e7936e477fd6c76d59a032de62458e6248012103d28046cd12e83832cca3fc4428d254e60092e06fa3f3b8de32062c1b07f58976005b63a8206bd66227651d0fe5c43863d7b29a4097e31dbf51e6603eee75947bff5e96ae438876a914882deed1aa2ea29cb7ba6ebe31b06c84c2fa0be267021701b17576a9141514817c58cc3937e09561f94b6b8e1cb60e92ec6888ac17010000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 52a580aad3f436096933dd6d3c58dc5131050bdc2d53eea416e934b0d699d89c.\n Sources:\n https://bitcoinops.org/en/topics/htlc/ https://wanwenli.com/blockchain/2018/06/28/Bitcoin-lightning-network.html https://github.com/bitcoin/bips/blob/master/bip-0199.mediawiki https://min.sc/#c=%2F%2F%20Traditional%20preimage-based%20HTLC%0A%28pk%28A%29%20%26%26%20sha256%28H%29%29%20%7C%7C%20%28pk%28B%29%20%26%26%20older%2810%29%29 https://en.bitcoin.it/wiki/Hash_Time_Locked_Contracts https://medium.com/@jkendzicky16/the-bitcoin-lightning-network-a-technical-primer-d8e073f2a82f#dd0c  ","link":"https://bitcoinpy.dev/docs/python-bitcoinlib/htlc/","title":"HTLC"},{"body":"todo\n","link":"https://bitcoinpy.dev/docs/buidl/p2tr/","title":"P2TR address"},{"body":"python-bitcoinlib currently does not support Taproot. Github Issue is open here.\n","link":"https://bitcoinpy.dev/docs/python-bitcoinlib/p2tr/","title":"P2TR address"},{"body":"Home of Bitcoin Python BitcoinPy is aiming to be the ultimate Bitcoin resource for Python developers.\nBitcoinPy is a living documentation of Bitcoin related Python libraries and tools with emphasis on providing code examples how to use Python to develop and interact with Bitcoin.\nGet Started\nIf you notice any issues, misinformation, have a suggestion for new content or have came across a bugs in the code examples...\nOpen a Pull Request or an Issue on GitHub.\n Join #bitcoin-python on Libera Follow the guide on joinin #bitcoin-python on Libera.\nJoin BitcoinPy on Telegram Join the Telegram group.\n Python shadowy super coders - UNITE!  ","link":"https://bitcoinpy.dev/","title":"Bitcoin resource for Python developers"}]